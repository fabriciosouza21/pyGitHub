{
  "comments":[
    {
      "comment":"Apologies if this has come up before; I'm unable to find any related issues.\r\n\r\nIt would be cool to be able to publish extensions in a beta form (similar to Code Insiders) so that they can be run \"in production\" with real users that have opted-in. This would reduce the disk in publishing an extension because you can push it to a smaller number of users for testing (I probably don't need to sell this to you, I guess you have Insiders for very similar reasons).\r\n\r\nI know we can package and distribute extensions ourselves for now, but it's not as easy (eg. updating is not automatic).\r\n\r\nI originally thought the \"Preview\" flag might've provided this functionality but unless I've overlooked something, it does not seem to.",
      "user":"DanTup"
    },
    {
      "comment":"I would very much like this myself.\n",
      "user":"ramya-rao-a"
    },
    {
      "comment":"Why not putting those experimental features behind a configuration setting and have the opt-in mechanism be toggling that setting to `true`? Once the feature is stable enough just remove the setting.",
      "user":"joaomoreno"
    },
    {
      "comment":"> Why not putting those experimental features behind a configuration setting and have the opt-in mechanism be toggling that setting to `true`?\r\n\r\nThis is an option, but I think it has some drawbacks\r\n\r\n1. If you want to do a beta release every day, your \"stable\" users will get the update notifications too\r\n2. It doesn't eliminate all the risk (if you're shipping bugs in the new features, maybe your feature detection is buggy, or how you're dealing with two code paths)\r\n3. For things that aren't just new features, it's more work to maintain/switch between the branches\r\n4. Users have to keep opting-in to each feature, rather than choosing to be a beta tester once; this could really limit the testing you get\r\n5. Having the feature toggles show up in the config auto-complete isn't ideal (this might not be an issue, but I didn't get a response to https://github.com/Microsoft/vscode/issues/1396#issuecomment-244350985 so it's unclear if \"hidden options\" are supposed to be used)\r\n\r\nNone of these issues are huge, but since the Insiders builds work so well and it seems like a similar scenario it seemed like a good request to raise for discussion :)",
      "user":"DanTup"
    },
    {
      "comment":"I agree, this would be a really useful feature. Right now I'm distributing our beta releases via VSIX downloads, but that is cumbersome and I don't reach many folks that way.\r\n\r\nHiding things behind a feature flag wouldn't really help. For example, we are about to release a new version that changes a lot of code, the whole architecture of the extension. There is no way that we could have had that behind a feature flag.",
      "user":"davidanthoff"
    },
    {
      "comment":"I would love to see this as well -- while feature flags work in certain cases, it doesn't cover them all. It also provides a sanity check and limits the \"damage\" of a bad release. And installing via vsix is just too user unfriendly to really be viable imo -- as it is completely manual. ",
      "user":"eamodio"
    },
    {
      "comment":"Just to kick this one again, because the issues surrounding the manual install and REQUIRED uninstall of vsix causes lots of pain for users and seemingly creates cases of corrupt installations -- I've definitely seen an up tick in GitLens issues caused by vsix/marketplace versions on top of one another.",
      "user":"eamodio"
    },
    {
      "comment":"Yeah, I meant to post back here - when I did a beta release a few months ago I had reports of issues installing/uninstalling the vsix:\r\n\r\n- https://github.com/Dart-Code/Dart-Code/issues/318#issuecomment-308244455\r\n- https://github.com/Dart-Code/Dart-Code/issues/318#issuecomment-308263912\r\n- https://github.com/Dart-Code/Dart-Code/issues/318#issuecomment-308279628\r\n\r\n",
      "user":"DanTup"
    },
    {
      "comment":"I gave up on vsix testing because of the complications mentioned above. Yesterday I shipped a huge bug that only occurred if `dart` on your `PATH` was a symlink (I had to make a lot of changes for multi-root support, and putting it all behind flags was not feasible) :(\r\n\r\nI'm starting to think about publishing a second version of my extension with Beta in the name to allow people to choose to test new releases earlier (seems like [at least one other](https://marketplace.visualstudio.com/items?itemName=webfreak.code-d-beta) has done this).",
      "user":"DanTup"
    },
    {
      "comment":"@DanTup @eamodio We did some improvements in this milestone (November) to support beta releases in VS Code when installed through VSIX. Refer to this issue https://github.com/Microsoft/vscode/issues/39024 for more details. Can you please check if that helps you in using VSIX?",
      "user":"sandy081"
    },
    {
      "comment":"@sandy081 Sounds good! Am I right in thinking november milestone is 1.19 and not released to stable yet? I'll try and do some testing latest this/next week.",
      "user":"DanTup"
    },
    {
      "comment":"Yes 1.19 will be released to stable this week. Let me know if you still want this feature to be opened after that.",
      "user":"sandy081"
    },
    {
      "comment":"@sandy081 Haven't had chance to test it yet; but I think there's still value in this feature even if vsix works better than it did, for example:\r\n\r\n- I think end users would have more confidence installing a beta vsix through the marketplace then from some random download url\r\n- Allowing people to opt-in to a beta channel would allow them to get auto-updates of betas instead of having to do manual installations all the time\r\n- Listing betas on the marketplace is much more discoverable - only a fraction of my users will follow the twitter account (etc.), so there are a lot of potential testers that simply won't know about beta vsix releases",
      "user":"DanTup"
    },
    {
      "comment":"@DanTup All your requirements are valid. But I think this has to be supported by the Market place first. \r\n\r\n@modigrv May I know if there are any plans to have this support in Market place?",
      "user":"sandy081"
    },
    {
      "comment":"This issue has been closed automatically because it needs more information and has not had recent activity. See also our [issue reporting](https://aka.ms/vscodeissuereporting) guidelines.\n\nHappy Coding!",
      "user":"vscodebot[bot]"
    },
    {
      "comment":"😔",
      "user":"DanTup"
    },
    {
      "comment":"Re-opening this issue as we haven't reached any conclusion yet.\r\nping @seanmcbreen and @modigrv on the question on marketplace",
      "user":"ramya-rao-a"
    },
    {
      "comment":"Our C/C++ extension wants to be able to publish insider builds to the marketplace so users who opt-in can automatically get either the \"insider\" version or the release version after that's published -- mostly to increase our real-world test coverage before pushing changes to everyone. We can publish the insider vsix to our GitHub site and email users about it who sign up for it, but it requires user to manually install it, so that isn't likely to get enough usage. We're fine with all VS Code Insiders users also getting the Insider extension instead of having a separate insider setting just for our extension.",
      "user":"sean-mcmanus"
    },
    {
      "comment":"I do not think we can do anything from VS Code side without such support from Market place. ",
      "user":"sandy081"
    },
    {
      "comment":"Where can folks give feedback that this is important? I thought leaving this issue open so that people can still like it might provide that option?",
      "user":"davidanthoff"
    },
    {
      "comment":"> We're fine with all VS Code Insiders users also getting the Insider extension instead of having a separate insider setting just for our extension.\r\n\r\nI don't think it'd be great to tie these together since it'd mean using the insiders version of your extension means that the user needs to be happy to switch also to Insiders Code and with it any other extensions that are publishing Insiders versions. I wouldn't want to go \"full unstable\" just to do it for one extension (for one, the stability of Insiders extensions could vary wildly across projects).\r\n\r\nIt also changes the environment somewhat, so you're not getting an accurate test of what happens if you publish the extension (unless ofc you wait for the next stable Code release).\r\n\r\n> I do not think we can do anything from VS Code side without such support from Market place.\r\n\r\nWhere can we show support for this? If this case stays closed, I suspect this will be forgotten about but it seems to be a good request desired by several extensions.",
      "user":"DanTup"
    },
    {
      "comment":"Yeah, having extension \"insider-ness\" be independent of VS Code itself is fine with me too. We just need the marketplace to allow us to submit an insider version and then VS Code would need to add an \"Install Insider\" button next to extensions that also have an insider version. Does the marketplace have some feedback site where this is being tracked?\r\n  ",
      "user":"sean-mcmanus"
    },
    {
      "comment":"They could even just re-use the `preview` flag -- I would bet users don't know what that is even supposed to mean (I don't -- other than some signal with regard to quality/stability/features -- but very nebulous and I bet doesn't stop bad reviews).",
      "user":"eamodio"
    },
    {
      "comment":"I guess the Marketplace would still need explicit support for this since people who don't want the preview/insiders/pre-release versions would expect to browser the marketplace and see the release notes (etc.) for the latest stable release, not the preview release.",
      "user":"DanTup"
    },
    {
      "comment":"Yeah, agreed -- there would definitely be a bunch of plumbing that they'd need to do on the marketplace side.",
      "user":"eamodio"
    },
    {
      "comment":"@viradhamMS @pkuma-msft We have a popular request to support beta/insiders versions of extensions which in turn needs Market place support.\r\n\r\nMay I know if there are any plans to have this support in Market place and what is the right Market place forum to raise these requests?\r\n\r\nReopening on users demand :)",
      "user":"sandy081"
    },
    {
      "comment":"Thanks folks. We do have a backlog feature to enable similar requirement. \r\nWhen we get to it, we will reach out to you folks to understand the requirements to finer detail.\r\n\r\nFor such feedback/questions on Marketplace, Please send a mail to vsmarketplace @ microsoft.com ",
      "user":"viradhamMS"
    },
    {
      "comment":"It seems like extensions themselves can implement their own insiders channel without marketplace support for users who have some \"yourExtension.insiders\" setting set:\r\n1. Downloading some json file that has the current insiders version (and URL) of the extension on activation (we already do this for on the fly a/b testing).\r\n2. If there's a new insider version, the extension can automatically download/install the vsix.\r\nAnd if you want more extension insider usage, you could set the default setting to true for VS Code insiders builds (requiring a package.json rewrite), and users could change the setting to false if they want the release version. This would hopefully solve our current problem in that our manually installed vsix has way too small 0.03% installs compared to the released version. It's on our backlog: https://github.com/Microsoft/vscode-cpptools/issues/1526 .\r\n\r\nTheoretically, this mechanism could be implemented in a way that is sharable between extensions via something like:\r\n1. Adding a setting extensions.insiders: [ \"ext1\": true, \"ext2\": false].\r\n2. Adding a property to package.json that sets the URL to download that points to a json file with the current insiders version and URL. We actually have 4 additional \"offline\" installer URLs for different platforms that wouldn't fit into this design, but we could ship just the online installer via this mechanism.\r\n\r\nBut I don't know how many other extensions would want to take advantage of this.\r\n",
      "user":"sean-mcmanus"
    },
    {
      "comment":"@sean-mcmanus that sounds very interesting. Personally I would like for vscode to somewhat \"approve\" a mechanism like this before I'd employ it in my extensions. ",
      "user":"eamodio"
    },
    {
      "comment":"While I was wanting this feature too, I have to say, the improved support for installing from .vsix files (without fear of conflicts) in #39024 is working nicely for me. Most people who have an issue with my extension are only interested in that one thing anyway. So I can attempt a fix, upload a beta .vsix file though github releases, and point them there. If everything's ok, I tell them to stick with that and then with the next marketplace release they're updated automatically and back on stable.\r\n\r\nNow of course... it work for all cases; large extensions that want a permanent beta channel. Just wanted to share for anyone that might have missed that change.",
      "user":"stkb"
    },
    {
      "comment":"The vsix fix is good; but I've had several beta releases in the last week or so. Telling users to keep updating vsix's kinda sucks. Having auto-updates of betas would make is so much easier - I wouldn't have to convince people to go download another vsix and install it :)",
      "user":"DanTup"
    },
    {
      "comment":"Hey everyone! I work on the PowerShell extension and would LOVE to have a preview/beta channel. In the meantime, I'm probably going to go down the route of having a separate extension [similar to what tslint does](https://marketplace.visualstudio.com/items?itemName=eg2.ts-tslint).\r\n\r\nShoutout to @mattbierner for pointing me here 👍 ",
      "user":"TylerLeonhardt"
    },
    {
      "comment":"FYI, the 0.19.0 C/C++ extension has implemented a C_Cpp.updateChannel setting with an \"Insiders\" option that will automatically check our GitHub releases page for a newer Insiders .vsix and download/install that: see https://github.com/Microsoft/vscode-cpptools/tree/release/Extension/src . Users of the Insiders VS Code have that setting defaulted to \"Insiders\".",
      "user":"sean-mcmanus"
    },
    {
      "comment":"@sean-mcmanus That's very cool -- though I would still really like this to be built-in/provided functionality.",
      "user":"eamodio"
    },
    {
      "comment":"Couldn't the ``preview`` tag in a published extension manifest be used for this? If a release has the ``preview`` property as ``true``, don't install it, unless a user opts into the \"preview\" channel for that extension. It seems to me that this wouldn't require any changes on the marketplace but could be implemented in VS Code itself?",
      "user":"davidanthoff"
    },
    {
      "comment":"To add to that, Ideally we'd want to be able to grab the latest non-preview if we want the stable channel, or the latest preview if we want the preview channel.",
      "user":"TylerLeonhardt"
    },
    {
      "comment":"@davidanthoff \"Preview\" is currently being used by some extensions for their \"release\" versions that are not considered \"feature complete\" enough for 1.0, so you'd be changing the meaning of the \"preview\" field. It would be better to check the version to see if it contains an \"-insiders<num>\" which is what our extension uses to implement our `\"C_Cpp.updateChannel\": \"Insiders\"`.",
      "user":"sean-mcmanus"
    },
    {
      "comment":"I see. In any case, I don’t understand why this can’t just be implemented in VS Code itself, why is there a need for a marketplace update?",
      "user":"davidanthoff"
    },
    {
      "comment":"VS Code's extension API doesn't have a generic concept of `\"<extension-setting-prefix>.updateChannel\"`, so they would have to add some package.json setting for extensions to provide what setting should be queried for that (or some other equivalent mechanism). If that is done, then they could use an implementation similar to what our C/C++ extension does to bypass the marketplace and query GitHub for new Insider vsix's.",
      "user":"sean-mcmanus"
    },
    {
      "comment":"Couldn't VS Code simply store somewhere in its own settings which extension is on a prerelease channel, and then check the marketplace whether there is an extension that has a version number that qualifies it as a prerelease?",
      "user":"davidanthoff"
    },
    {
      "comment":"@davidanthoff How would VS Code determine if an extension is on a prerelease channel? There needs to be some API or package.json for setting that (e.g. an \"updateChannel\" or \"updateChannelSettingName\" field in package.json). The marketplace only allows submission/publishing of one version at a time -- we can't submit a 0.20.1 and 0.21.0-insiders without changes to the marketplace implementation (only the last submitted would be used).",
      "user":"sean-mcmanus"
    },
    {
      "comment":"But aren't all versions that have ever been published stored on the marketplace? I just tried this with our julia package, and I can get any old version with a link like\r\n````\r\nhttps://marketplace.visualstudio.com/_apis/public/gallery/publishers/julialang/vsextensions/language-julia/0.8.0/vspackage\r\n````\r\nI guess the problem is that the extension can't get a list of all the uploaded extension versions?",
      "user":"davidanthoff"
    },
    {
      "comment":"@davidanthoff Yeah, I think you're right about all the older versions being saved (we used to tell users to use that when there was some breaking regression), but VS Code would need a way to query the marketplace for the list (or the latest Insiders versus non-Insiders). It's possible such an web API exists, but I haven't checked. Our extension queries https://api.github.com/repos/Microsoft/vscode-cpptools/releases for the version list.",
      "user":"sean-mcmanus"
    },
    {
      "comment":"That API you linked has whether or not a version is a prerelease or not. Could we go down the list for the last non-prerelease?\r\n\r\nAlso couldn't help but notice cpptools is following semver so that could also be leveraged, potentially. ",
      "user":"TylerLeonhardt"
    },
    {
      "comment":"@TylerLeonhardt Do you mean the GitHub API? That only works for our extension because we post our Insider .vsix's on GitHub and we have custom code that queries it and updates our extension with that. VS Code itself could do something similar to give other extensions the ability to have an Insider channel -- as mentioned previously, there just needs to be some mechanism for exposing the per-extension setting to turn the Insider mode on or off. FYI, our extension has gotten thousands of users on our Insiders, so we consider it a success (compared to tens of users previously, with the \"manually discover/download/install the vsix\" approach).",
      "user":"sean-mcmanus"
    },
    {
      "comment":"Oof my bad. Got confused on who is who in this thread and totally thought the API you linked was from the marketplace 😄\r\n\r\nif the marketplace has an API similar to GitHub's... that could be leveraged in vscode to achieve the NuGet Package Manager-like experience of installing extensions - checkbox to allow prerelease/insiders/previews... which filters the list.",
      "user":"TylerLeonhardt"
    },
    {
      "comment":"[This](https://github.com/Microsoft/vscode/commit/2d931dc4cbe89eadf72fa84b600d71e5c3a8eaab#diff-5a704040f30e3eb4463336a47e6500cbR581) seems an API that can pull all versions that are on the marketplace. I think with that all the pieces should be in place that this issue here could be implemented without any changes to the marketplace:\r\n1. VS Code stores per extension whether it should get pre-release versions for that version or not and exposes a UI for that setting\r\n2. If an extension is configured for pre-release, it pulls the info about all available versions from the marketplace via the API I linked to, and then gets the newest release that has say ``beta`` or something like that in the semver.\r\n3. If an extension is not configured for prereleases, it just installs the latest \"normal\" version, based on the version property.\r\n\r\nEssentially I think one could implement this in the same spirit that https://github.com/Microsoft/vscode/issues/12764 was implemented, and distinguish between release and prerelease versions on the version property. CCing @sandy081, given that he did the arbitrary version installation stuff.",
      "user":"davidanthoff"
    },
    {
      "comment":"@davidanthoff I'm not aware of a per-extension setting in VS Code -- maybe the \"setting\" could just be exposed via the right-click menu in the Extensions pane, like the \"Install Another Version...\" option is. Also, in order for us to switch to this VS Code implementation, the per-extension setting would need to default to \"Insiders\" for users of VSCode Insiders, because that's how we get most of our current Insider usage (and enable people who don't want to be on Insiders to change the default).",
      "user":"sean-mcmanus"
    },
    {
      "comment":"Implemented a workaround for this by shipping two extensions...\r\n\r\nPreview\r\nhttps://marketplace.visualstudio.com/items?itemName=ms-vscode.PowerShell-Preview\r\n\r\nStable\r\nhttps://marketplace.visualstudio.com/items?itemName=ms-vscode.PowerShell\r\n\r\nI ended up running into a strange issue trying to release a `2.0.0-preview.1` version of the Preview package:\r\n![can't use 2.0.0-preview](https://user-images.githubusercontent.com/2644648/51644469-1cdce380-1f25-11e9-911c-9530357ac8ce.png)\r\n\r\nNo support for SemVer 2! :(\r\n\r\nSo I tried to use `2.0.0.0` instead and npm doesn't support 4 numbers... only SemVer 2 format!\r\n\r\nIt's been a wild ride... I really hope the code team can do something about this.\r\n\r\nRight now extensions can only be X.X.X versioned.\r\n\r\ncc @auchenberg who I was chatting a bit about this on [Twitter](https://twitter.com/TylerLeonhardt/status/1088147478459772928)",
      "user":"TylerLeonhardt"
    },
    {
      "comment":"In some ways I like that I can't accidentally publish a dev release. I'm really nervous when I type `vsce package` that I might push a dev build to all users!\r\n\r\nI wonder if we could still have a prefix that was vblocked (eg. `-dev`) even it became possible to upload other pre-release versions (in order to support this). There would need to be some work in VS Code and on the site to let users see/pick between stable/preview releases, but being able to see versions in VS Code now seems like a step towards this.",
      "user":"DanTup"
    },
    {
      "comment":"Out of curiosity, where does one file issues against the Marketplace? It sounds like we need to raise awareness to the folks who maintain the Marketplace as well as the vscode team (who are obviously already on this thread.)",
      "user":"beriberikix"
    },
    {
      "comment":"@beriberikix - You can file issues here itself, we work very closely with VSCode group and it will reach us pretty quickly (or) feel free to directly post to vsmarketplace at microsoft dot com",
      "user":"viradhamMS"
    },
    {
      "comment":"A feature like this would help out immensely for pushing new features. I'm hoping the marketplace/vscode team will get on it soon!",
      "user":"natanfudge"
    },
    {
      "comment":"Currently most of the extensions are following a separate extension for extension insiders/nightly. This way, users can opt in to install either stable/insiders version of extension and disable the other. It is also **NOT** limited to insiders/stable.\r\n\r\nAny feedback on this solution?",
      "user":"sandy081"
    },
    {
      "comment":"I don't think it's the best solution - it means you're listed twice in the marketplace, have two sets of reviews/stats, and have to fiddle around when publishing to change the extension ID.\r\n\r\nIt also means extensions that reference each other by ID (for example Dart & Flutter are dependent and call exported APIs) need some faffing around too (to know to check which version is installed).\r\n\r\nAnd of course, we'd need to do our own checks that the user didn't install multiple versions.\r\n\r\nI think being able to publish pre-release versions to the marketplace (even if it's a white-listed set, like `-beta`) and let users have a flag per-extension to opt in the using pre-release versions would be far better (and I don't think it should be tied to VS Code Insiders).",
      "user":"DanTup"
    },
    {
      "comment":"Your concerns are valid.\r\n\r\nAnother approaches we are discussing which is based on what is suggested here\r\n\r\n## Approach 2: Defining Insiders Flag (VS Code hosted solution)\r\n\r\n- Introduce an insiders flag for extensions which can be provided in the `package.json` and follow the same versioning system `major.minor.patch`. \r\n\r\n- Provides a way (some UI) to the user to install the stable or opt in for insiders in VS Code. User can always switch between stable and insiders flavour of extension even after installing.\r\n\r\n**Drawbacks**\r\n\r\n- Following the same versioning system will be confusing to use between insiders and stable. How does an insiders version is numbered without pre-release version tags?\r\n\r\n- Since insiders version will be always latest, Markeplace shows insiders version of an extension like read me, version etc.,\r\n\r\n## Approach 3: Insiders version tag (Marketplace hosted solution)\r\n\r\n- Allow pre-release version tags `x.x.x-insiders` for extensions. \r\n\r\n- While browsing (VS Code or Marketplace) always show stable version by default unless requested to see insiders version.\r\n\r\n- Provides a way (some UI) to the user to install the stable or opt in for insiders in VS Code. User can always switch between stable and insiders flavour of extension even after installing.\r\n\r\nI would prefer Approach 3 which is correct IMO and has no drawbacks compared to other solutions. But this has a dependency on Marketplace to support this feature.",
      "user":"sandy081"
    },
    {
      "comment":"Yes, I'm also much in favor of approach 3!\r\n\r\nI think it would be nice if the pre-release tags would support things like `v1.4.3-alpha.2`, `v1.4.3-beta.3`, `v1.4.3-rc.1` etc. and then would automatically do the right thing. If that is too complicated, maybe just `v1.4.3-insiders.3` would do the trick as well. But it would be good if one could publish consecutive pre-release versions that are uniquely identified.",
      "user":"davidanthoff"
    },
    {
      "comment":"I also prefer 3, since it seems weird if we have to keep revving non-preview version numbers for preview/insiders builds (however if it's likely to take significantly longer because it needs marketplace changes, I'd revise my preference ;-))\r\n\r\nI'd also ask that `-insiders` builds can have additional build numbers (eg. `-insiders.1`, `-insiders.2`, `-insiders.3` etc.).",
      "user":"DanTup"
    },
    {
      "comment":"I also strongly prefer 3",
      "user":"eamodio"
    },
    {
      "comment":"As mentioned previously, our C/C++ extension implements this ourselves with our C_Cpp.updateChannel settings, so if the marketplace implements something similar it is important that our extension is able to:\r\n1. Default to Insiders for VS Code Insiders.\r\n2. Be able to show a prompt such as \"Insiders version is available. Would you like to switch to the Insiders channel?: [Yes][Ask Me Later][Don't Show Again]\" that can change the version.\r\n\r\nWithout those 2 features our Insider usage would be too low to be useful. Our code that does this is open source, but it's not packaged to be re-usable by other extensions.\r\n\r\nAs mentioned by the other users, some sort of 0.23.0-insiders, 0.23.0-insiders2 mechanism is desired: see https://github.com/microsoft/vscode-cpptools/releases .\r\n\r\nThe main disadvantage with our method is that our Insider versions are not available via the  \"Install Another Version...\" UI in VS Code...so if an API was available to make that fixable I'm not sure why we'd benefit from a marketplace change.",
      "user":"sean-mcmanus"
    },
    {
      "comment":"Without knowing the true architecture of the VSCode marketplace, I can only guess... But since vsix's are very similar to nuget packages, my guess is that the marketplace (VSCode, VisualStudio, etc) is some fork of NuGet.org (or NuGet.org is some fork of the marketplace). Also, the PowerShell Gallery is a fork of NuGet.org. \r\n\r\nBoth NuGet.org and PowerShell took approach 2. My guess is because of the risk of doing approach 3 and making sure that we are still backcompat. Imagine trying to replace a bunch of SemVer v1 code with SemVer v2... There could be a ton of side effects.\r\n\r\nWith all that said, I would prefer approach 3 because it's the technically correct approach... But my understanding is that that's a different team and this would be a large ask so it's tough on that front.\r\n\r\nIm voting for Approach 2 only because I think a lot of Approach 2 is needed for Approach 3 (like the toggle in vscode to show/hide insiders) and it will take the least amount of time and coordination.\r\n\r\n\r\nAll the while, the marketplace team could be working on Approach 3... And then vscode uses that version instead of the preview flag when their work is done. ",
      "user":"TylerLeonhardt"
    },
    {
      "comment":"I think with Approach 2 extension authors will have troubles in version their stable and insiders versions. I really do not know what the model would be for versioning stable and insiders with `major.minor.patch`. For example if the current stable is `1.1.0` what is the next insiders version?",
      "user":"sandy081"
    },
    {
      "comment":"If you went with 2, I'd probably just use even minor versions for stable releases and odds for insiders to keep things in order:\r\n\r\n```\r\n1.0.0 <-- stable\r\n1.1.1 <-- insiders version of 1.2\r\n1.1.2 <-- insiders version of 1.2\r\n1.2.0 <-- stable\r\n1.3.1 <-- insiders\r\n1.4.0 <-- stable\r\n```\r\n\r\nIt's not perfect since you can't have insiders versions of patch releases, but that doesn't seem like a *huge* issue IMO.\r\n\r\n(I'm not saying I'd like 2, but if the difference between delivering that and 3 is a long time - it's been over 2 years since I opened this already - then I'd take it!)",
      "user":"DanTup"
    },
    {
      "comment":"I agree with @DanTup. That seems reasonable if it means we get the feature a lot sooner.\r\n\r\nWith the PowerShell extension, we recently followed the Python extension and switched to date-based versioning like `2019.8.0` where it's `year.month.buildThatMonth`. Leveraging that versioning scheme, with the `preview` property in the package.json determing prerelease (aka Approach 2) would work nicely for us.\r\n\r\nP.S. We switched to that versioning scheme because we accidently shipped the preview extension (`2.0.0`) to the stable extension... It was a very painful experience to mitigate. We couldn't risk using Semver anymore having 2 extensions to manage.",
      "user":"TylerLeonhardt"
    },
    {
      "comment":"If we went with 3), one could have a concept of a \"channel': one could have a `nightly` channel, a `beta` channel (that is more stable and has fewer releases) etc.\r\n\r\nThe versioning scheme could be `v1.20.3-nightly.4` and `v1.20.3-beta.2` etc.\r\n\r\nAt the end of the day, I think that is what I'd _really_ like to have and it seems to be really useful in lots of other contexts (Windows, Edge etc.)",
      "user":"davidanthoff"
    },
    {
      "comment":"This would a great feature addition! Any timeframe on when this might land?",
      "user":"janosh"
    },
    {
      "comment":"I seem to be getting different versions depending on whether I am on VSCode Insiders\r\n\r\n```\r\nName: C/C++\r\nId: ms-vscode.cpptools\r\nDescription: C/C++ IntelliSense, debugging, and code browsing.\r\nVersion: 0.26.2-insiders2\r\nPublisher: Microsoft\r\nVS Marketplace Link: https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools\r\n```\r\n\r\n```\r\nName: C/C++\r\nId: ms-vscode.cpptools\r\nDescription: C/C++ IntelliSense, debugging, and code browsing.\r\nVersion: 0.26.1\r\nPublisher: Microsoft\r\nVS Marketplace Link: https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools\r\n```\r\n\r\nBut it looks like `cpptools` manually implemented that feature...\r\nhttps://github.com/microsoft/vscode-cpptools/pull/3221",
      "user":"vchuravy"
    },
    {
      "comment":"@vchuravy Yes, and that's the default behavior, but it can be overridden via our C_Cpp.updateChannel setting. There's a bug preventing it from working for remote machines though (https://github.com/microsoft/vscode-cpptools/issues/3833).",
      "user":"sean-mcmanus"
    },
    {
      "comment":"It would be fantastic if extensions wouldn't have to implement this feature, but VSCode could offer it by default.",
      "user":"vchuravy"
    },
    {
      "comment":"@vchuravy Yeah, I agree. Our implementation is open source if any other extension wants to do something similar, but we haven't packaged it into an easily re-usable npm module. Other than the remote bug, our insider system has worked really good for our extension, allowing us to find/fix important bugs before they get released to a wider audience (and allowing users to get updates earlier than our slower 1.5 month non-Insiders release cadence).",
      "user":"sean-mcmanus"
    },
    {
      "comment":"Is there any hope that this will make it to the top of the list of the core dev team? I think given that this needs integration with the marketplace, it really can only be done by the core team.\r\n\r\nEvery time we release a new version of our extension, I wish we had this. In my mind this is single feature that has the most amazing potential to increase the quality of the entire extension ecosystem.",
      "user":"davidanthoff"
    },
    {
      "comment":"I would love this",
      "user":"GustavoASC"
    },
    {
      "comment":"We now caved and are publishing a second version of the Julia extension that is an insider build. The whole situation is really not great because the normal and the insider extension now conflict with each other, but it is better than nothing.\r\n\r\nIf anyone is interested in the Azure pipeline we use that creates the insider build, take a look [here](https://github.com/julia-vscode/julia-vscode/blob/a7248f87cc9a82482b1975b82f4f8656123a78f7/azure-pipelines.yml#L201). It makes the necessary modifications to the `package.json` and swaps out the README.\r\n\r\nI still _really_ hope that at some point we'll get a proper solution for this...",
      "user":"davidanthoff"
    },
    {
      "comment":"From reddit: https://www.reddit.com/r/vscode/comments/fakre5/hey_extension_authors/fj0r2az/\r\n\r\n> I can speak to beta extensions. This is one of the most requested features for the marketplace and we're actively working on this one.\r\n",
      "user":"DanTup"
    },
    {
      "comment":"Having 2 extensions - the regular and the insider one raise a problem so the user can't have both of them. I've not digging into it but probably the issues are with duplicate ids of commands, views etc.\r\nIn principal, we can run a task to replace the ids with insider ids but it's very uncomfortable.",
      "user":"moshfeu"
    },
    {
      "comment":"@moshfeu I'm eagerly awaiting beta releases as a first-class citizen, but as a workaround for your issue, you should be able to have the regular version look for the insider version (with [this api](https://code.visualstudio.com/api/references/vscode-api#extensions)) and disable itself if the latter is installed.",
      "user":"J-Fields"
    },
    {
      "comment":"Thanks @J-Fields . The conflicts coming from the \"contributors\" - for example, buttons and commands. I'm not sure how using the API can solves this 🤔",
      "user":"moshfeu"
    },
    {
      "comment":"This would prevent a lot of headaches to extension users :)\r\nI'd prefer the possibility for the user to easily rollback to the latest stable version if he accidentally opted-in ;) ",
      "user":"misak113"
    },
    {
      "comment":"It would be cool like `Google Play Store` So the entire journey from alpha to production would be covered here.",
      "user":"anburocky3"
    },
    {
      "comment":"Upstream https://github.com/microsoft/vsmarketplace/issues/165",
      "user":"isidorn"
    },
    {
      "comment":"@sandy081 and me have been thinking about this topic and we understand that there are a lot of problems with the current approach of publishing two extensions: confusing for users, inconsistent across extensions, painful to manage both. We believe that the current separation of insiders and regular into two extensions does not make sense. Here's our proposed solution:\r\n\r\n- Continue to use current `major.minor.patch` version semantics but provide a way to extension authors to mark a version as insiders by introducing a flag say `--insiders` to `vsce` during the `publish` step. \r\n- Given that MP supports publishing smaller/older versions (given that the version is not published already), Extension authors can still release insiders and stable (including patches) in parallel. One recommendation is to use `patch` for insiders versions but extension authors are free to use any numbering model given that they use only `major.minor.patch` semantics. **Example:** \r\n  - Assume that you have a stable released version `1.0.0` and want to release next insiders version.\r\n  - You can release next minor insiders versions as follows: `1.1.0`, `1.1.1`, ....... , `1.1.25` (marking them using `--insiders flag through vsce)\r\n  - You can promote above insiders version to stable version by releasing `1.1.26` and start working on next insiders versions `1.2.0`... just like above.\r\n  - If you want to fix a bug in previous stable ie., `1.1.*`, you can fix the bug and release `1.1.27`.\r\n- When users uses either VS Code Stable or VS Code Insiders to install an extension, the user would get the latest stable version of the extension. This is an open question: should VS Code insiders users get the insiders extension automatically?\r\n- Users could manually switch from a Stable extension version to an Insiders (context menu action). Extensions will still auto-update respecting their \"quality\" - insiders extensions would update to latest insiders, stable only to stable extension versions\r\n- Insiders extensions will be decorated specially in the extensions view \r\n- It is up to extension authors to deprecate their old separate \"Insiders\" version of the extension and all settings which might control this (C++ and Python). Either by using notifications or something else. We are willing to help with this transition.\r\n- Long term 18 months (upstream dependency): MarketPlace will add support for pre-release versions (e.g. 1.60.2-insiders). Once that is done we might deprecate the `--insiders`.\r\n\r\n### Drawbacks of this approach\r\n\r\n- **Version ambiguity**:  Since one cannot use prerelease part of semver and have to rely on `major.minor.patch` parts for insiders, this creates strange version history and cannot differentiate insiders vs stable by looking at versions. \r\n- Marketplace will always display the latest version of the extension on its website (even if it is marked as insiders version).\r\n- Current users of Insiders extensions would have to uninstall the Insider extension, and install the regular extension. And potentially opt in to the insiders version. Might be hassle. Probably we can mitigate this by VS Code handling this.\r\n\r\nAbove drawbacks will be lifted once MP supports prerelease version tags.\r\n\r\nPlease let us know what you think about this proposal. We are looking forward to the feedback. Thanks 👏 \r\n\r\nAuthors of extensions that have nightly versions @eamodio @connor4312 @alexr00 @aeschli @brettcannon @davidanthoff @dantup @wardengnaw @polinasok @hediet @greazer @TylerLeonhardt",
      "user":"isidorn"
    },
    {
      "comment":"@isidern I like the proposed solution!\r\n\r\nWould vscode-stable users who installed an insider-extension also be updated to stable-builds of that extension if the stable build is newer than the insider build? (I think this makes sense if the extension does not always have an insiders build)\r\n\r\nIn this case, insider-users who got updated to stable should still get the newest insider build of the extension once it gets published. Thus I think the decision what to update to should not be based on the stability of the installed extension, but rather be a separate (user-configurable) flag.",
      "user":"hediet"
    },
    {
      "comment":"@hediet \r\n\r\nThats a good point to note and Yes, we will be doing that - Irrespective of being on insiders/stable version of an extension users we will always have the best latest ie., \r\n- if stable is latest than insiders then always stable. \r\n- if insiders is latest than stable then insiders (only when in VS Code insiders or users opted to insiders version of extension)",
      "user":"sandy081"
    },
    {
      "comment":"@rchiodo Mentioned using the `\"engines\"` property to limit a release to VS Code Insiders, not sure everyone is aware of that option:\r\n```json\r\n    \"engines\": {\r\n        \"vscode\": \"1.59.0-insider\"\r\n    },\r\n```\r\n",
      "user":"chrmarti"
    },
    {
      "comment":"> @rchiodo Mentioned using the `\"engines\"` property to limit a release to VS Code Insiders, not sure everyone is aware of that option:\r\n> \r\n> ```json\r\n>     \"engines\": {\r\n>         \"vscode\": \"1.59.0-insider\"\r\n>     },\r\n> ```\r\n\r\nBut `1.60.0` is newer than `1.59.0-insider`, right? At least by the semver spec.",
      "user":"hediet"
    },
    {
      "comment":"Updated the proposal based on feedback (added drawbacks) and simplified that Stable Extensions would get downloaded for any VS Code flavour and users would have to opt into getting insiders extensions. We can later change this that by default VS Code insiders gets Insiders extensions. This is out of scope for this proposal.",
      "user":"isidorn"
    },
    {
      "comment":"What is the plan for user discoverability when it comes to this? With a separate nightly extension you get the SEO for your insiders version by showing up as a separate search result. Bundling under the same extension ID means you lose that. So would users then be expected to check every extension to see if there's an insiders version they can switch to? Or would extensions come up with their own way to \"advertise\" their insiders version to users and ask them to click the right thing to switch? Or would there be an `execCommand` we could use as part of a notification prompt to help users flip over to insiders?",
      "user":"brettcannon"
    },
    {
      "comment":"The proposed plan would work well for Pylance; I designed our versioning to follow semver (technically, calver) with this eventuality in mind. Our stable releases are like `2021.9.1`, and our insiders are like `2021.9.2-pre.1` (insiders builds are always semantically newer than stable builds).\r\n\r\nI was worried about the case where insiders users update to stable builds, when we want them to move up to other insiders builds, but I this already happens now as VS Code can update the extension to stable before we get a chance to manually install the VSIX. When a stable build of Pylance is release, we release a corresponding insiders build, so it's probably rare that anyone checks for an update during that small period and would work better than our manual daily checks.",
      "user":"jakebailey"
    },
    {
      "comment":"I was hoping the default for VS code insiders would be to install the latest insiders (or stable if newer build)\r\n\r\nThen it would happen automatically. The special ask the user if they want to opt in means nobody will end up using our insiders bits.\r\n\r\nRight now we're using the engines property to accomplish just that. All VS code insiders users get our insiders version automatically (or stable version if it's newer).",
      "user":"rchiodo"
    },
    {
      "comment":"@isidorn VS Code Insiders defaulting to the latest Insiders extension (or stable if it's newer) is also a \"requirement\" for our extension to switch to this mechanism (instead of our current custom one) -- otherwise, Insider usage would be \"too low\" (we could probably provide telemetry data on this if you want).",
      "user":"sean-mcmanus"
    },
    {
      "comment":"Similar for Pylance; our custom insiders system also respects the Python extension's insiders setting, which gets us a more reasonable number of users. It's hard to make this discoverable.",
      "user":"jakebailey"
    },
    {
      "comment":"I think we should not talk about \"newer\" or \"latest\" builds, but _higher versioned_ builds.\r\n\r\n>  Irrespective of being on insiders/stable version of an extension users we will always have the best latest ie., if stable is latest than insiders then always stable.\r\n\r\nThis is not a good behavior in my opinion. For example, often in recovery releases I'll go back and publish, for example, a `1.60.2` release even when the `1.61.0-insiders.1234` is available. In this case users on 1.60.1 should be updated, but those on the 1.61.0 nightly should not be. That is:\r\n\r\n- For users on the \"insiders\" track, always install the highest-versioned build available compatible with `engines.vscode`\r\n- For other users, install the highest-versioned *non-prerelease* build available compatible with `engines.vscode`\r\n\r\n\r\nAside from that I think the proposal looks good.",
      "user":"connor4312"
    },
    {
      "comment":"@connor4312 I believe all references to \"newer\" and \"latest\" do mean \"higher versioned\" builds, and the release of 1.60.2 would not affect the 1.61.0-insiders if it's released later, i.e. it's just a word choice difference.",
      "user":"sean-mcmanus"
    },
    {
      "comment":"Yea, just want to clarify that there should not be any chronological implication when we talk about version numbers. I thought there was currently a bug in the marketplace where that was assumed, but it looks like it's actually a separate issue (extension auto update only checks for the highest versioned release of an extension, but if its engines.vscode is not compatible with the current vs code version the auto update stops working; I misremembered and thought the problem was that it only returned the most recently published version)",
      "user":"connor4312"
    },
    {
      "comment":"if insider avaible, IMO, I want this:\r\nbefore installed:\r\n![image](https://user-images.githubusercontent.com/1876302/132930641-d273ea2b-a6d3-4da0-9f76-7c79a6476735.png)\r\n\r\nafter installed:\r\n![image](https://user-images.githubusercontent.com/1876302/132930660-d9aa8370-6438-4069-a3ed-c0116568a6e4.png)\r\n",
      "user":"heartacker"
    },
    {
      "comment":"> I think we should not talk about \"newer\" or \"latest\" builds, but higher versioned builds.\r\n\r\nI'd like to add, the current behavior works very well for the Jupyter extension. We have releases for both stable and insider builds, and we ship recovery builds for stable every now and then, and insider builds on a daily basis\r\n\r\nFor Jupyter extension, if used wants insider builds, we just ask then to use the vscode insider builds (ie all vscode insider users automatically get the insider build of Jupyter extension). We haven't had any request from users to have insider builds of the extension in the stable version of vscode.",
      "user":"DonJayamanne"
    },
    {
      "comment":"> If a version has been published as insiders, it can not be promoted to stable, a new version has to be pushed. Can create strange version history for extensions\r\n\r\nTo clarify - does this mean _version numbers_? Eg. If I publish a 1.25.0 with `--insiders`, I cannot then also publish 1.25.0 without `--insiders`? Or does it just mean that we have to push the file again and can't just flip a flag? I'm assuming it's likely the former if the Marketplace isn't handling this and VS Code is instead tracking which versions were marked as insiders? (out of curiosity - how is this working is vsce just adding some additional metadata to the vsix?).\r\n\r\nI think having the marketplace show the Insiders version number might be confusing, but it sounds like that's unavoidable without the Marketplace being updated. I'd certainly live with it to have Insiders versions :-)\r\n\r\nI agree with other users though - having Insiders users automatically get Insiders by default would be nice to improve usage (or at least make the install view have the Insiders option more prominent).",
      "user":"DanTup"
    },
    {
      "comment":"@brettcannon Your discoverability concerns are valid and we will definitely address this while coming up with UX mock ups. Our current thinking is to let VS Code handle this and not by extensions, so that users will get unified consistent experience.\r\n\r\n@connor4312 Just to be clear about current proposal - **We are not changing current version semantics ie., extension still supports only `major.minor.patch`. We defer supporting prerelease version tag until Marketplace supports it.** Your scenario of publishing 1.60.1 when there is 1.61.0-insiders is supported only then. With the current proposal you still have to follow existing `major.minor.patch` version semantics but you can tell VSCE / VSCode that a specific version is a an insiders/prerelease one. Unfortunately you have to release a newer/higher version for your insiders, if you have a stable release. So in your case, you have to publish 1.60.1 as stable and 1.60.2 as insiders. This is mentioned as a drawback to the proposal and I agree that it does not sound good and adds some strange version gaps but this temporary and will be lifted once MP supports prerelease tags.\r\n\r\n> To clarify - does this mean version numbers? Eg. If I publish a 1.25.0 with --insiders, I cannot then also publish 1.25.0 without --insiders? Or does it just mean that we have to push the file again and can't just flip a flag? I'm assuming it's likely the former if the Marketplace isn't handling this and VS Code is instead tracking which versions were marked as insiders? (out of curiosity - how is this working is vsce just adding some additional metadata to the vsix?).\r\n\r\n@DanTup  your assumption is correct. Yes, with current approach VSCE/VSCode are just tracking the versions marked as insiders. Once MP supports prerelease versions we will move to it. Yes, we will be adding this as metadata to vsix for now.",
      "user":"sandy081"
    },
    {
      "comment":"What would the MP link to for downloading? The Python extension gets sideloaded a lot due to aggressive firewalls blocking VS Code hitting the MP for updates, so having the download link in the MP be the stable release would be good. Making the link just the highest versioned thing, insiders or not, can cause issues for extensions like Jupyter where users don't realize that the thing they are downloading from the MP is actually the insiders build and not the stable build.",
      "user":"brettcannon"
    },
    {
      "comment":"@brettcannon my understanding is that there will be _no_ changes to the marketplace in the short-term for the proposal above, so it _will_ just show the highest version number regardless of stable/insiders (because it won't know which are stable and which are insiders - only vsce and VS Code will understand that).\r\n\r\nIt's definitely not perfect, but if it's really likely to be 18 months for the Marketplace to get support, I'd rather have this. It's been almost 5 years since I opened this issue 🙃",
      "user":"DanTup"
    },
    {
      "comment":"Before I created a separate Insiders extension for GitLens (and the same for GitHub Repositories) I think I would have (for the most part) loved this proposal, but now I feel there are significant issues with using the same extension id for both a stable and unstable build, at least in how VS Code handles data for them.\r\n\r\nHaving shared data storage for stable and unstable extensions, can be hugely problematic, not only for backward compatibility, but now you will have to deal with users switching back and forth between versions -- and with synced data this can get even more problematic. Granted extensions internally could try to deal with this, by storing their own data in separate stable vs unstable buckets, but that adds even more complexity (and must be understood before you hit the problem).\r\n\r\nVS Code could, of course, store stable vs unstable data in separate buckets automatically and that might address most of my concerns.\r\n\r\nOutside of the data concerns, I also feel like versioning will be challenging -- not only just getting the right thing published, but also for error reporting (since the main parts of the version are going to be either the same of very close). I definitely like how today both GitLens & GitHub Repositories use standard versioning `1.5.0` while the insiders version are `YYYY.MM.DDHHMM`. Which make it easy to tell the difference, but also how recent your insiders build it (since they are basically nightly builds). Maybe the `--insiders` or maybe better yet a `--prerelease-channel <name>` flag could not only specify the channel, but also affect the versioning structure -- so maybe all prereleases are versioned by the date.\r\n\r\nAlso if we think of this concept all as pre-release \"channels\" where the user can choose the channel they want to be in, it will be something easier to manage for authors, users, and the marketplace. On the marketplace, you could then show version histories by channel, download/upgrade by channel, etc. And maybe the number of channels and names are publisher controlled -- or maybe they are something we try to standardize on. And maybe vscode insiders get, by default, opt-ed into a pre-release channel, which they can opt-out of individually or globally. But in this way we aren't just thinking about version numbers -- version numbers are a secondary consideration after the channel.\r\n\r\nAnyway that my 2c.",
      "user":"eamodio"
    },
    {
      "comment":"@DanTup for us it's more of a question as to whether we use this mechanism or publish a separate nightly extension for the next 18 months. We have a lot of users who sideload the Python extension, so having that \"download\" link in the MP point to something that isn't our stable release will be a support burden as people will inevitably open issues about getting our insiders build from there no matter how well we try to document where to actually download from.",
      "user":"brettcannon"
    },
    {
      "comment":"@brettcannon Yep, I understand. Presumably the proposal above doesn't prevent you from continuing as you are today, and consolidating things when the marketplace is updated.\r\n\r\nFor me, having a second extension would actually mean having a 3rd and 4th (Dart + Flutter - the Flutter extension has a dependency on Dart, so there couldn't be a Dart Insiders without also a Flutter Insiders) and I'd have to deal with users potentially having both sets installed. Having a single-extension solution would definitely be better for me even with the compromises above.",
      "user":"DanTup"
    },
    {
      "comment":"Thanks a lot for feedback 👏  This week we plan to listen to your suggestions and to discuss this with the team. Next week we should have a definite decision if we will go down this road. Though let me try to answer some questions:\r\n\r\n1. Good point by @eamodio to use different storage if extension is stable or insiders. This makes sense and if we implement the proposal @sandy081 and me will explore this\r\n2. I have contacted the Marketplace team to see how much effort it would be for the Marketplace site to show the latest \"non insider\" version instead. I'll update here once I hear back from them.",
      "user":"isidorn"
    },
    {
      "comment":"@DanTup we just got feedback similar to your dependency explosion issue from @jakebailey as Pylance depends on our Python extension.\r\n\r\nI expect we will go with whatever @isidorn and @sandy081 come up with and just be as clear as possible in our docs about where to download a stable VSIX to side-load (if the Marketplace team doesn't come back with \"good\" news for @isidorn 😉).",
      "user":"brettcannon"
    },
    {
      "comment":"All, please note the following change in the [proposal](https://github.com/microsoft/vscode/issues/15756#issuecomment-916728348) \r\n\r\nGiven that MP supports publishing smaller/older versions (given that the version is not published already), Extension authors can still release insiders and stable (including patches) in parallel. One recommendation is to use patch for insiders versions but extension authors are free to use any numbering model given that they use only major.minor.patch semantics. Example:\r\n- Assume that you have a stable released version 1.0.0 and want to release next insiders version.\r\n- You can release next minor insiders versions as follows: 1.1.0, 1.1.1, ....... , 1.1.25 (marking them using `--insiders flag through vsce)\r\n- You can promote above insiders version to stable version by releasing 1.1.26 and start working on next insiders versions - 1.2.0... just like above.\r\n- If you want to fix a bug in previous stable ie., 1.1.*, you can fix the bug and release 1.1.27.\r\n\r\nThis will allow you to continue releasing insiders and at the same time you can release stable patches without affecting insiders version.",
      "user":"sandy081"
    },
    {
      "comment":"We really appreciate the feedback and we will make a final decision next week whether to go ahead with the proposal.\r\nIn the meantime two more questions that I would like to get your feedback on:\r\n1. Should VS Code insiders users gets insiders extensions by default? Or the insiders users need to opt-in to the insiders extensions?\r\n2. If a user is on an Insider extension, and a new Stable version of that extension is released that has a higher version than the insider version. Should the user be updated to the just released stable? In other words opting to insiders does the user always get highest version even if that version is stable or not?\r\n",
      "user":"isidorn"
    },
    {
      "comment":"1. This might depend on the target stability of an insiders extension. If that's more on the experimental side, opt-in makes sense, if it's on the release-candidate side, opt-out will work better because it ensures a larger number of users will get it.\r\n2. Extensions might enable experimental features in insiders versions, therefore insiders should stay on insiders also when there is a more recent stable version. (This seems similar to VS Code Insiders.) We might need a way for extensions to say when the insiders channel is discontinued, otherwise users might end up installing an out-of-date version.",
      "user":"chrmarti"
    },
    {
      "comment":"1. I'd probably prefer them to get Insiders by default, but I think @chrmarti makes some good points. Even if they have to opt-in, that still seems better than what we have today (and the two-extension thing is ofc already opt-in).\r\n2. I think Insiders should stay on Insiders to avoid confusion, but again I don't feel too strongly about this. It's likely after a stable release I'd be making an Insiders release with a higher version number anyway.",
      "user":"DanTup"
    },
    {
      "comment":"1. Maybe allow the extension to decide?",
      "user":"gjsjohnmurray"
    },
    {
      "comment":"1. I'd prefer insiders by default. Opt-in means a lot less insiders users for us and more confusion when asking people to try out fixes. Right now we just say if you want to try this fix, install VS code insiders.\r\n2. I think I'd prefer insiders stay on insiders for the reasons that @chrmarti explained. Insiders bits can sometimes have experimental stuff that we're only trying in insiders and even if it doesn't, all fixes that end up in stable are always in insiders first for us anyway (so even if stable is newer, insiders will quickly follow).",
      "user":"rchiodo"
    },
    {
      "comment":"1. Our extension would highly prefer VS Code Insiders to get Insiders extensions versions by default; otherwise, Insider usage would drop too much.\r\n2. Our extension would prefer Insiders to use the highest version, whether insiders or non-insiders, since our non-Insiders with a higher version is always a newer version than the previous Insiders -- that behavior could be overridden by extensions by publishing an insiders with a higher version as discussed in https://github.com/microsoft/vscode/issues/15756#issuecomment-919784379 and \"experimental\" features that are not desired in the higher versioned non-Insiders could potentially be enabled via a setting instead of relying on a vsix version. This would allow our extension to publish 1.7.0-insiders, then 1.7.1, and then 1.8.0-insiders later on; otherwise, we'd have to publish 1.7.1 and 1.8.0-insiders simultaneously with identical bits, which would be unnecessary, although not a major issue.\r\n\r\nA package.json setting to allow extensions to opt-in to the different update behaviors would be fine too.",
      "user":"sean-mcmanus"
    },
    {
      "comment":"1. For Pylance, it would be beneficial to have insiders automatically get insiders extensions, but this isn't something we have now, and I'll personally be happy with any sort of increase in this userbase, be it from it being auto-installed or the UI being extended to show that insiders versions are available (which is going to have to happen anyway). I can see this potentially causing an issue from the POV that people trying out VS Code insiders will not only get VS Code's unstableness, but any unstableness from every extension they have installed that also has insiders.\r\n2. I don't know if it makes sense for extensions to be upgraded from insiders to stable; if storage is separated out as in https://github.com/microsoft/vscode/issues/15756#issuecomment-919359976, this will probably cause oddities as users move back and forth within the channels. For example, we might intend to show a popup once (then never again), except that moving between stable/insiders will effectively clear that status. In Pylance's case, every time we publish a stable version, we also automatically publish a new insiders build that is semantically newer (so 2021.9.2 is equivalent to 2021.9.3-pre.1), so I'm not too worried either way.",
      "user":"jakebailey"
    },
    {
      "comment":"> I don't know if it makes sense for extensions to be upgraded from insiders to stable; if storage is separated out as in Allow extensions to publish beta releases and users to opt-in to them #15756 (comment), this will probably cause oddities as users move back and forth within the channels.\r\n\r\n@jakebailey I do not think we would be having separate storages for stable & insiders of the extension. As of now we would like to go with current model - one storage per extension. Having two storages will be an advanced feature request going forward.",
      "user":"sandy081"
    },
    {
      "comment":"> Maybe allow the extension to decide?\r\n\r\n@gjsjohnmurray Yeah, extensions can do that by using vscode engine property in package.json. They can force insiders to use insiders of an extension by setting vscode insiders version in vscode engine property of package.json. This is what Jupyter & Remote Containers extensions are doing currently.",
      "user":"sandy081"
    },
    {
      "comment":"For (2) my vote is in the court that Insiders users be updated to Stable if the most recent stable version > insiders. This matches the semver model to avoid inventing new mechanics for VS Code's versioning. Perhaps the `ExtensionContext` has a `updateChannel` enum that lets the extension know whether this is a stable or insiders user in order to enable/disable features?",
      "user":"connor4312"
    },
    {
      "comment":"Overall, the proposal is very helpful for the Java extension since we need an insider version to expand the visibility of our beta features. For the two questions:\r\n\r\n1. I suggest VS Code insiders users could get insiders extensions by default. Since Java extension doesn't have an insider version yet, this will help our insider extensions used by more users and they can also have a change to switch back to the stable versions if needed.\r\n2. When `--insiders` becomes available, we plan to release a new stable version along with a new insider version to keep the newest semantic version of Java extension is always the insider version, just like what VSCode insiders and Pylance do (mentioned before). Thus, Java extension will not meet this problem, I'm OK with both choices.",
      "user":"CsCherrYY"
    },
    {
      "comment":"Thank you very much for your great feedback. After a milestone of house keeping and thinking about all of this @sandy081 @misolori and me plan to do the following this milestone:\r\n* Continue to use the current `major.minor.patch` version semantics but provide a way to extension authors to mark a version as insiders by introducing a flag `--insiders` to `vsce` during a publish step\r\n* If a user opts to insiders extension the user will always get the highest version even if that version is stable\r\n* For VS Code Insiders users by default we will offer users to get the Insiders extensions (image attached). We will use a dropdown so users can easily choose to go with the stable version instead. On VS Code stable users can still choose but the default option will be to install the Stable version of the extension.\r\n* If an extension has an Insiders version available we will always render the Green badge in the upper right corner to indicate this both in VS Code Stable and Insiders\r\n* There will be an easy way for users to switch between Stable and Insiders versions of an extension. Both for VS Code Stable and VS Code Insiders\r\n* We will provide migration support for extensions. For example, when the separate [GitLens (Insiders)](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens-insiders) extension gets deprecated VS Code will automatically install the regular [Git Lens](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens) extensions and switch it to the Insiders version. We will also transition the extension state. Extension authors will have to contact us for this explicitly\r\n* Marketplace will render the latest non Insiders extension version on the Marketplace site\r\n\r\n### Default Experience\r\n<img width=\"1100\" alt=\"CleanShot 2021-11-12 at 09 35 23@2x\" src=\"https://user-images.githubusercontent.com/35271042/141510235-7eaa9a4a-2048-473b-b616-b4f9dc06e366.png\">\r\n\r\n### Switching to Insiders\r\n\r\n<img width=\"1055\" alt=\"CleanShot 2021-11-12 at 09 36 05@2x\" src=\"https://user-images.githubusercontent.com/35271042/141510305-fc1da832-7e62-461d-b9d8-e84d10737c5f.png\">\r\n",
      "user":"isidorn"
    },
    {
      "comment":"@isidorn thanks for the update\r\n\r\n> We will provide migration support for extensions. For example, when the separate Git Lens Insiders extension gets deprecated VS Code will automatically install the Git Lens extensions and switch it to the Insiders version. We will also transition the extension state. Extension authors will have to contact us for this explicitly\r\n\r\nThe above didn't make much sense. Your are talking about migrating insider gitlense to insider.\r\n",
      "user":"DonJayamanne"
    },
    {
      "comment":"@DonJayamanne thanks. I have tried to clarify this by editing that sentence and by adding links to clarify which extension I am exactly talking about in what part of the sentence. Hope it is clearer now. ",
      "user":"isidorn"
    },
    {
      "comment":"Thank you all for the great work. Here I have another question, can extension have a way to know whether it's an insider version itself in runtime? Thus, we can use different APIs easily.",
      "user":"CsCherrYY"
    },
    {
      "comment":"> Thank you all for the great work. Here I have another question, can extension have a way to know whether it's an insider version itself in runtime? Thus, we can use different APIs easily.\n\nI don't think it's a good idea. Same extension with same version should has same behaviour, no matter insider or not.\n\nI think for your case you can get version string in runtime, and use different API according only to the version.",
      "user":"jks-liu"
    },
    {
      "comment":"@isidorn sounds neat! I presume if we push a stable version that's higher than the last insiders version, everyone (including insider-extension-version users) will be upgraded to it, but VS Code will remember those that were on the \"insiders channel\" so if we then push another Insiders version, those users would update back to that?",
      "user":"DanTup"
    },
    {
      "comment":"Yes, that's correct.",
      "user":"sandy081"
    },
    {
      "comment":"@isidorn Thanks for the update.\r\n\r\nI think I'm good with most of this, but my biggest concern is when a user transition from an insider's version back to stable. Thinking mainly of data and settings migrations that could have happened that could now cause issues with the stable version (leading to a broken or unstable \"stable\" version). For stored data this can be mitigated more easily by storing the data for stable vs insiders differently (e.g. scoping the key), but with settings it gets a bit trickier. Maybe this is mostly a non-issue as dealing with these issues would only arise in a small set of extensions, but it might be good to have some documentation around best-practices to handle/avoid them.\r\n\r\nMy other thought is around versioning, but I think it might be a non-issue (though I haven't thought through all the scenarios). Most Insiders/Nightly extensions I've see use a date/time versioning model, of which I think is highly valuable to both the extension and the user, and I think given the rules outlined above an extension could still utilize this versioning. Since Insiders versions using `YY.MM.DDHHMM` (or similar) would always be greater than the stable version, so you'd never get \"upgraded\" from Insiders to Stable (which imo can be desirable). Are there any other issues with try to keep that versioning scheme (if an extension wanted) that you all can think of?\r\n\r\nA couple of thoughts/clarifications on the UI mocks:\r\n - In the images of the 2 versions of GHPR -- they both seem to say they are the same version. I'm guessing (hoping) that was just a mockup issue, and if you were on version `1.5` on stable, and you switch to insiders (and the latest is `2021.11.151010`) then `2021.11.151010` will be shown as the version in the UI? \r\n - It seems redundant to have the \"This extension has an Insiders version available\" message when you are on the insiders version -- almost makes it feel a bit broken.\r\n - I think there should be a badge or something applied to the extension in the list when you are running an insiders version -- easier to scan for -- I think it probably should warrant a badge on the extension overview page too\r\n - I think it would be nice for extensions to be able to provide an insiders icon image if they want to further differentiate the editions\r\n - I think the terminology of \"Switch to [Insiders|Stable] Extension\" on the button could be improved by calling them Channels (or Editions, though I much prefer channels). I think it could also help users better understand what they are opting into. Other platforms use the channels metaphor.\r\n\r\n> For VS Code Insiders users by default we will offer users to get the Insiders extensions (image attached). We will use a dropdown so users can easily choose to go with the stable version instead. On VS Code stable users can still choose but the default option will be to install the Stable version of the extension.\r\n\r\nCan you show a mock of what this would look like for a first time install? Both in the list and in the overview page? ",
      "user":"eamodio"
    },
    {
      "comment":"@eamodio thanks a lot for the feedback. Let me try to answer your questions:\r\n\r\nYes, we should think more about what transition from Stable to Insiders extensions means for data and settings and we should document it. @sandy081 probably has more thoughts here\r\n\r\nNo, I do not see other issues with that versioning scheme.\r\n\r\n1. Yes, this is a mockup issue\r\n2. I agree. We'll improve this in the real version\r\n3. There is a green circle badge in the top right which shows this. We can fine tune this\r\n4. This is a fair feature request, not sure if this might be possible to do already if an extension publishes a different icon every time it publishes the `insiders` editions. I understand this is a manual process and we might need something more straight forward. Good feature request after we ship this\r\n5. I like the word \"channel\". We could use \"Switch to Insiders Extension Channel\" / \"Leave Insiders Extension Channel\". Might be too long. We decided to not use the word \"stable\". @misolori for thoughts\r\n\r\nFirst time install for VS Code Insiders would look something like this (mock still in polish phase)\r\n\r\n![Screenshot 2021-11-16 at 11 24 59](https://user-images.githubusercontent.com/1926584/141968152-b8fbb383-1dad-443b-af39-7b2fb3d6f712.png)\r\n\r\n",
      "user":"isidorn"
    },
    {
      "comment":"@isidorn I've been thinking about the versioning more as we consider what it would be like to transition the C++ extension to this system.  Previously, if our upcoming release was, say, 1.5.0, we would have 1.5.0-insiders, 1.5.0-insiders2, etc, and then finally 1.5.0 (stable).  We don't do daily insiders releases and only start releasing them when new features are available for evaluation.  The way VS Code determined which extension to install was based some kind of \"greater than\" check, so our developers in the insiders program would automatically be upgraded to \"stable\" when the evaluation period for a release had completed.\r\n\r\nIt occurs to me that with this new way if only x.y.z versioning is supported, we'd have to do versioning one of two ways:\r\n\r\n**`x.y.0` is the first stable**\r\nIdeally, when we release a new version, the patch number is `.0`.  In order to achieve this, it seems we'd have to release insiders for `x.y` as `x.(y-1).z`.  This might be confusing because it doesn't indicate that new features are becoming available since only the patch version is changing.\r\n\r\nExample:\r\nCurrent stable release is `1.4.0`.  We release the first insiders as `1.4.1`, second insiders as `1.4.2`.  When stabilized we release `1.5.0`.\r\n\r\n**`x.y.z` is the first stable**\r\nIn order to ensure that our insiders are upgraded to stable at the end of the evaluation period, we would start releasing insiders as `x.y.0`, then `x.y.1`, `x.y.2` for subsequent insiders releases. The first stable release would have a version number of `x.y.z`.\r\n\r\nExample:\r\nCurrent stable release is `1.4.3`.  We release the first insiders as `1.5.0`, second insiders as `1.5.1`, etc.  When stabilized we release `1.5.3` (or whatever the current patch number is).\r\n\r\n\r\nThe nice part about using the `-` in our versions currently is that it allows us to denote that new features are coming (increment the minor version number) and also release the first stable with a patch number of 0.\r\n\r\nCan we continue to use `-` in our versions when publishing with `--insiders`, or how would you recommend we do our versioning going forward?",
      "user":"bobbrow"
    },
    {
      "comment":"@isidorn Thanks!\r\n\r\nI like the idea of Switch/Leave the insiders channel -- I think you can shorten it to `Switch to Insiders Channel` / `Leave Insiders Channel` or even `Join Insiders Channel` / `Leave Insiders Channel`. \r\n\r\nAlternatively, rather than buttons, this could be a \"[Release] Channel\" dropdown that has a `Stable` (or `Release`) and `Insiders` options.\r\n\r\nBut I think in any of these options there needs to be some explanatory text as to what an insiders version/channel is.",
      "user":"eamodio"
    },
    {
      "comment":"- I do not think we would like to handle any data partition or migration for stable and insiders versions of the extensions. VSCode would treat this as a normal update to higher/lower version. We will make it clear about this in the doc and also recommend such extensions to use separate storage keys (append with insiders for eg) for differentiating. \r\n\r\n- I think using **Channel** might send different message about this feature. Briefly, with this feature, VSCode is allowing users to install and use insiders/pre-release versions of an extension. For such users, VSCode will always install the latest version of the extension and this can be a pre-release or release version. So the name `Join/Leave the Insiders Channel` might convey that user will be always in Insiders channel even if there is latest stable. It is up to the extension to always have a latest insiders version and force users to be on insiders version but it is not mandatory. Yes, I agree that we have to improve on conveying this message in our UI. \r\n\r\n- Using patch version for pre-release tags is a temporary solution because Marketplace does not support pre-release tags at present. We (VSCode & Marketplace) have plans to support pre-release tags (SemVer) going forward and once it is available you can start using pre-release tags and follow the same release cycle as you are using now, ie., `1.5.0-insiders` -> `1.5.0-insiders2` -> `1.5.0` without any big adoptions/changes and it will work seamlessly. Until then we recommend to use patch part for pre-release/insiders versions as mentioned in this [comment](https://github.com/microsoft/vscode/issues/15756#issuecomment-916728348)\r\n\r\nCC @eamodio @bobbrow @isidorn  ",
      "user":"sandy081"
    },
    {
      "comment":"Thanks @sandy081 ",
      "user":"bobbrow"
    },
    {
      "comment":"> Briefly, with this feature, VSCode is allowing users to install and use insiders/pre-release versions of an extension.\r\n>\r\n> <https://github.com/microsoft/vscode/issues/15756#issuecomment-970482005>\r\n> <https://github.com/microsoft/vscode/issues/15756#issuecomment-971450154>\r\n\r\nWhat about still having just one \"**Install**\" button and adding a \"**Receive Insiders**\" switch next to it?\r\n\r\n```text\r\nInstall | ☑ Receive Insiders\r\n\r\nThis extension has an Insiders version.\r\n```\r\n\r\n```text\r\nDisable | Uninstall | ☑ Receive Insiders\r\n\r\nYou are receiving an Insiders version. This extension is enabled globally.\r\n```\r\n\r\n```text\r\nDisable | Uninstall | ☐ Receive Insiders\r\n\r\nAn Insiders version is available. This extension is enabled globally.\r\n```\r\n",
      "user":"Lemmingh"
    },
    {
      "comment":"@Lemmingh thanks for your feedback, however we have decided on the current design, we are currently in the \"polish wording\" phase.\r\n",
      "user":"isidorn"
    },
    {
      "comment":"We have pushed this feature to Insiders 🚀  \r\nWe are in the process of testing it. If all looks good end of this week I will write docs for extension authors on how to best adopt to this and I will share them here. \r\n[GitHub Pull Request extension](https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-pull-request-github) adopted to this, so for those who are eager to try out the flow can use VS Code insiders and that extension to see how it looks.",
      "user":"isidorn"
    },
    {
      "comment":"We have released a VS Code stable that supports this 🚀 \r\nHere are the extension author docs that should help you adopt to pre-release extension support\r\nhttps://code.visualstudio.com/api/working-with-extensions/publishing-extension#prerelease-extensions\r\n\r\nIf there are any questions do not hesitate to reach out. Looking forward to feedback. Thanks a lot 👏 ",
      "user":"isidorn"
    },
    {
      "comment":"@isidorn awesome! Two questions:\r\n\r\n- what happens if we publish a pre-release version now, for users that haven't upgraded VS Code yet? Would they see the pre-release version as an update, or would it be filtered out on the server?\r\n- in a comment above you said \"Marketplace will render the latest non Insiders extension version on the Marketplace site\" but on the page at https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-pull-request-github it shows `Version | 0.35.2021120909` which looks like an insiders version (I see 0.34.0 in VS Code as the stable version). Is this a bug, or has the marketplace not been updated yet?",
      "user":"DanTup"
    },
    {
      "comment":"@dantup good questions:\r\n* `vsce` will require you to specify an engine property in your pre-release version so that older VS Code versions will not be able to use it. So users that haven't upgraded will not be offered the pre-release version\r\n* Correct, MP has not yet done this work. This item tracks the work here https://github.com/microsoft/vsmarketplace/issues/264 In the end we decided to have more UI decorations to make it clearer to the user that it is a pre-release version. We should have something on the MP side by the time most of the extensions adopt to this (end of January). Let's continue the discussion on that issue for this.",
      "user":"isidorn"
    },
    {
      "comment":"> `vsce` will require you to specify an engine property\r\n\r\nAh, perfect. Thanks! :-)",
      "user":"DanTup"
    },
    {
      "comment":"@isidorn Thanks for the hard work. We're looking forward to a way to publish Type Hierarchy feature as a preview feature and pre-release extension is a great choice. However, the related APIs are in proposed state (see https://github.com/microsoft/language-server-protocol/pull/1231#issuecomment-929296135 and https://github.com/microsoft/vscode-languageserver-node/blob/main/client/src/common/proposed.typeHierarchy.ts), enabled by `enabledApiProposals` and we can't publish it even to the pre-release channel.\r\n\r\nThe question is that we want to find a way to take advantage of the pre-release channel to make more users use our preview features with proposed APIs, is that possible? Or is there any consideration about this?",
      "user":"CsCherrYY"
    },
    {
      "comment":"@CsCherrYY there have been some discussions around this but nothing definite yet. We want to make sure that the `pre-release` extension support is adopted smoothly across our community before we decide to build any additional features on top.",
      "user":"isidorn"
    },
    {
      "comment":"Is there some way to find out from code whether the currently running extension was installed as a pre-release version or not? We want to send telemetry to different destinations, depending on whether a user is running a pre-release version or not.",
      "user":"davidanthoff"
    },
    {
      "comment":"> Is there some way to find out from code whether the currently running extension was installed as a pre-release version or not? We want to send telemetry to different destinations, depending on whether a user is running a pre-release version or not.\r\n\r\nA version cannot be both pre-release and not pre-release, so if you manage the extension, then you are in control of the process for launching pre-release versions and therefore know which versions are pre-release. If you follow the suggestions outlined in the documentation:\r\n\r\n> we recommend that extensions use major.EVEN_NUMBER.patch for release versions and major.ODD_NUMBER.patch for pre-release versions. For example: 0.2.* for release and 0.3.* for pre-release.\r\n\r\nthen you can easily check the current extension version and act accordingly based on whether is an even or odd minor release. ",
      "user":"TwitchBronBron"
    },
    {
      "comment":"@davidanthoff exactly as @TwitchBronBron explained: you can look at your extension version and act accordingly.",
      "user":"isidorn"
    },
    {
      "comment":"There's a lot to read through in this issue and I wasn't sure what the expected behavior is with regards to 'insiders'.\r\n\r\nShould insiders users automatically be updated the prerelease of an extension?\r\n\r\nThis isn't currently happening for the [Jupyter Extension](https://marketplace.visualstudio.com/items?itemName=ms-toolsai.jupyter).\r\n\r\nI had to explicitly pick 'Switch to prerelease version'\r\n\r\n![image](https://user-images.githubusercontent.com/19672699/148584097-a4ebc807-eba5-424a-a126-89239eed6e93.png)\r\n",
      "user":"rchiodo"
    },
    {
      "comment":"Uh oh...if VS Code Insiders users have to manually opt-in, we're likely to see our Insiders usage drop by a lot. @bobbrow Are you sure we should switch to the new mechanism if that's the case? And/or can we get VS Code to change the behavior first?",
      "user":"sean-mcmanus"
    },
    {
      "comment":"We support automatically migrating separate extensions to the pre-release version of the main extension - extension authors just have to inform us they want this.\r\nHowever since C++ and Jupyter have a special case and you do not have separate extensions we currently do not support automatic migration done by VS Code. However you can do the migration on your own as discussed here https://github.com/microsoft/vscode-cpptools/issues/8507#issuecomment-994178165",
      "user":"isidorn"
    },
    {
      "comment":"For me just now, when I used Insiders and searched for the GHPRI extension (which I know published pre-releases), the Install button defaulted to Pre-Release:\r\n\r\n![image](https://user-images.githubusercontent.com/6726799/148587401-104ddc2d-ce21-4a32-9717-bbce39b56a94.png)\r\n\r\nDoing the same with Stable defaults to a regular install:\r\n\r\n![image](https://user-images.githubusercontent.com/6726799/148587621-cba0edc6-7bf0-4107-8dee-9fdf1703f2ea.png)\r\n\r\n",
      "user":"gjsjohnmurray"
    },
    {
      "comment":"> We support automatically migrating separate extensions to the pre-release version of the main extension - extension authors just have to inform us they want this. However since C++ and Jupyter have a special case and you do not have separate extensions we currently do not support automatic migration done by VS Code. However you can do the migration on your own as discussed here [microsoft/vscode-cpptools#8507 (comment)](https://github.com/microsoft/vscode-cpptools/issues/8507#issuecomment-994178165)\r\n\r\n@isidorn I'm not sure that's going to work? Won't it force all users to the latest? For me I didn't want the latest, but when I do, it should show me the latest is the prerelease version. That's the behavior we have right now. Users pick when they upgrade, but the recommended upgrade is the most recent insiders only build.",
      "user":"rchiodo"
    },
    {
      "comment":"@gjsjohnmurray correct.\r\n@rchiodo yes, the insiders users will by default get the option to install Pre-Release. My previous answer was my misunderstanding of your question. For me this just works\r\n\r\n![Screenshot 2022-01-07 at 19 12 18](https://user-images.githubusercontent.com/1926584/148588034-e44b3b7c-8ea8-4d16-af6b-d88d0abe5918.png)\r\n\r\n",
      "user":"isidorn"
    },
    {
      "comment":"@rchiodo you would just do that code for your insider version of the extension. So that way you would transition only your insider users to the new pre-release version.",
      "user":"isidorn"
    },
    {
      "comment":"@isidorn  that's the behavior with the jupyter extension not already installed. But if it was already installed, the update notification won't pick prerelease.\r\n\r\nAnd I believe the command suggested would force an update? Maybe I'm wrong about that.",
      "user":"rchiodo"
    },
    {
      "comment":"I guess it won't be terrible to force prerelease if the extension isn't already in insiders for a specific version (one time thing).\r\n\r\nMaybe we can add code to ask the user on insiders.",
      "user":"rchiodo"
    },
    {
      "comment":"@rchiodo there is just one minor thing missing to have this flow super nice https://github.com/microsoft/vscode/issues/139528\r\nWe plan to tackle this in the next two weeks.\r\n\r\nAnd yes. So my full suggestion is the following:\r\n1. For your current Insiders jupyter version do the following\r\n2. Show a persistent notification to the user, or a modal dialog \"bla bla we moved to pre-release - click here to be migrated\"\r\n3. Once user clicks -> execute [the code](https://github.com/microsoft/vscode-cpptools/issues/8507#issuecomment-994178165). Once #139528 is done all should be good\r\n\r\nHope I was more clear now. Thank you",
      "user":"isidorn"
    },
    {
      "comment":"Also another way to ensure users don't automatically get switched to a non-insiders release (if that is what you want) -- you can have your insiders versions always be greater than stable version. For example in GitLens I am planning to keep my `YYYY.MM.DDHH` version format for insiders.",
      "user":"eamodio"
    },
    {
      "comment":"> Also another way to ensure users don't automatically get switched to a non-insiders release (if that is what you want) -- you can have your insiders versions always be greater than stable version.\r\n\r\nGitHub Pull Requests and issues does the same thing. Before releasing a new stable, we will always release a new insiders with the increased version.",
      "user":"alexr00"
    }
  ],
  "repository":"vscode",
  "user":"DanTup"
}