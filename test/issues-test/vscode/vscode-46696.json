{
  "comments":[
    {
      "comment":"Users sometimes want to set SDK paths local to their project to pin the versions of them (or to progressively move projects to the next version). There are two places where they'd want these paths to apply:\r\n\r\n1. The extension uses it to load the correct SDK (eg. for language services, debugger, etc.)\r\n2. In the integrated terminal\r\n\r\nCurrently it doesn't seem like there's a way to provide a path once to be used for both of these purposes so the user has to set the path in two places (one in extensions settings and the other in terminal path) and keep them in sync.\r\n\r\nI thought maybe I could read the terminals path and use that when locating my SDK, but I tried this:\r\n\r\n```js\r\n{\r\n  \"terminal.integrated.env.windows\": {\r\n    \"PATH\": \"${env:PATH};C:\\bin\"\r\n  }\r\n}\r\n```\r\n\r\nHowever if I read that value from `\"terminal.integrated.env.windows\"` I get the literal string above without the `${env:PATH}` being resolved. Although I could resolve that myself as a special case, maybe there's a better way to handle this (like allowing the user to specify paths that will be prepended to the terminal paths that extensions could use too).",
      "user":"DanTup"
    },
    {
      "comment":"@sandy081 is there a way to read settings in the API and then resolve the variables inside them?",
      "user":"Tyriar"
    },
    {
      "comment":"@Tyriar Following is the API to read configurations\r\n\r\n`vscode.workspace.getConfiguation()`\r\n\r\nBut I do not think there is an API to resolve variables. \r\n\r\n@isidorn might have an idea?",
      "user":"sandy081"
    },
    {
      "comment":"@DanTup @sandy081 there is no extension API to resolve variables\r\nWe do not support variables resolving in settings inside vscode (there is a seperate feature request). Dut to the above it is not possible to read settings in the API and resolve variables",
      "user":"isidorn"
    },
    {
      "comment":"My request here is not specifically about resolving variables, but rather about providing some solution to this problem. I don't think reading from the terminal path as suggested above is the best one. However, I do think it'd be good to provide some way for a user to be able to specify folder-level paths that would apply to in-built terminals *and* be readable by extensions to allow projects to be pinned to specific versions of SDKs/cli tools.",
      "user":"DanTup"
    },
    {
      "comment":"@DanTup \r\n\r\nRe: SDKs, If I understand correctly, you are asking for the support for the user able to provide paths to SDKs relative to the current workspace in settings? For example like \r\n\r\n```json\r\n\"java.sdk\": \"${workspace}/lib/java/sdk\r\n```\r\nAnd when the extension gets the resolved value when the above setting is read?\r\n\r\nI am not sure if I understand the relation between in-built terminals and specific versions of SDKs. Can you please elaborate more ?\r\n\r\n\r\n",
      "user":"sandy081"
    },
    {
      "comment":"@sandy081 It doesn't need to be relative, I just want the user to be able to configure a path at a workspace-level that will be used for two things:\r\n\r\n1. By my extension to look find the SDK\r\n2. By Code to prepend to the `PATH` variable for integrated terminals\r\n\r\nI already have a setting for `1` (`dart.sdkPath`/`dart.flutterSdkPath`) however because Code doesn't use them, if the user types `dart` or `flutter` in the integrated terminal then they'll get the version from their normal `PATH` and not the version they've pinned this project to.\r\n\r\nObviously it doesn't make sense for Code to read my specific settings, so I'm hoping Code can support a general setting for users to configure `PATH`s for the integrated terminal that is also reasonable for extensions to read for their own searching.\r\n\r\nMaybe if the user could prepend paths so that there are no variables required or something?\r\n\r\n```js\r\n{\r\n  \"terminal.integrated.env.windows\": {\r\n    \"PATH\": {\r\n      \"prepend\": \"C:\\bin\",\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nI'd also like to be able to set it, so that if the user picks an SDK from a picker, I can write it somewhere that will apply to newly created terminals.",
      "user":"DanTup"
    },
    {
      "comment":"Maybe it shouldn't be inside `terminal.integrated` but a more general workspace setting for \"additional paths\" that can be pre-pended by terminals and also consumed by extensions.",
      "user":"DanTup"
    },
    {
      "comment":"@Tyriar After going through above comments, it looks like this request is to support PATH in the integrated terminal.",
      "user":"sandy081"
    },
    {
      "comment":"To be clear, the request is for a *workspace-level* `PATH` which is also readable by extensions.",
      "user":"DanTup"
    },
    {
      "comment":"Is https://github.com/Microsoft/vscode/issues/45692 a solution to the same problem? You can then have some path as a setting:\r\n\r\n```\r\n\"go.gopath\": \"C:\\\\some\\\\path\"\r\n```\r\n\r\nAnd then resolve a command inside the .env. setting?\r\n\r\n```\r\n \"terminal.integrated.env.windows\": {\r\n    \"PATH\": \"${env:PATH};${command:go.gopath}\"\r\n  }\r\n```\r\n\r\nOr a setting?\r\n\r\n```\r\n \"terminal.integrated.env.windows\": {\r\n    \"PATH\": \"${env:PATH};${setting:go.gopath}\"\r\n  }\r\n```",
      "user":"Tyriar"
    },
    {
      "comment":"@Tyriar Almost! That would still require the user to do two things:\r\n\r\n1. Set the SDK via the extension\r\n2. Configure their path to call the command\r\n\r\nDoing this in every project is tedious. Most likely the user will start a new project, change their SDK, then discover the terminal is wrong and be frustrated they have to go copy/paste this chunk again.\r\n\r\nReally I'd like something that an extension can write that would automatically be pre-fixed into the paths. Eg., in Dart Code you can click on the SDK version in the status bar and quickly change it:\r\n\r\nhttps://dartcode.org/docs/quickly-switching-between-sdk-versions/\r\n\r\nI guess it's very similar to the TypeScript version picker. We'd like this to seamlessly fix paths for the terminal (for new ones, at least, we don't expect existing terminals to be affected). While we could probably write to that setting above, I think it may require a restart, and it'd be nice if we could do this invisibly (not have an additional change show up in addition to the SDK path we've already written for the extension to use).\r\n\r\nIdeally, I'd want it to just be as simple as something like this in my workspace settings:\r\n\r\n```js\r\n{\r\n  \"env.additionalPaths\": [\r\n    // ...\r\n  ]\r\n}\r\n```\r\n\r\nThese would be prefixed into terminals paths and extensions are free to read/write them. The setting isn't specific to the extension or the terminal, it's a generic way for the user to tell anyone that cares that they have some preferred paths for this workspace that should be searched before `PATH`. We'd use them first for looking for SDKs and if the user uses our sdk-picker we will insert into the top of that array (and remove anything we know is an older SDK).",
      "user":"DanTup"
    },
    {
      "comment":"> While we could probably write to that setting above, I think it may require a restart, and it'd be nice if we could do this invisibly\r\n\r\nYou are correct that you won't be able to touch existing terminals, but you shouldn't need a restart. What I was thinking was you could check if the setting has been set and give a notification if that's the case, otherwise just set it.\r\n\r\n> These would be prefixed into terminals paths and extensions are free to read/write them. \r\n\r\nI'm hesitant to promote `PATH` to something more than just another environment variable that it is now.\r\n\r\n---\r\n\r\n@ramya-rao-a @DonJayamanne any opinions on this? Seems relevant to most language extensions.",
      "user":"Tyriar"
    },
    {
      "comment":"Not sure whether we need to do anything here. Other tools already do stuff like this: https://github.com/kennethreitz/autoenv\r\nI would have though an alternative would be to make use of a startup script to achieve this (something already supported in VSC).",
      "user":"DonJayamanne"
    },
    {
      "comment":"@DonJayamanne I'm not really sure how that would work - I want something that can easily be read by an extension, and I can't parse shell scripts. I also want this to be really simple for the end user - currently we're just writing the path into a single setting - if we start writing shell scripts into their folder, that doesn't seem like a simple solution.",
      "user":"DanTup"
    },
    {
      "comment":"@Tyriar \r\n\r\n> I'm hesitant to promote PATH to something more than just another environment variable that it is now.\r\n\r\nThat's not really what I wanted - I was after something new that is combined with path by the terminal. It doesn't seem crazy that an extension should be able to contribute additional paths to the embedded terminal. The current mechanism for that is a little clunky (it's platform-specific, for example, and it's also [broken](https://github.com/Microsoft/vscode/issues/46693)).",
      "user":"DanTup"
    },
    {
      "comment":"The Go extension has a similar issue. Not with the PATH env var but GOPATH.\r\nThere are a series of fallbacks in the Go extension to determine the GOPATH. Once determined, we update the `process.env['GOPATH']` to that value. This was done so that the user doesnt have to worry about setting different GOPATHs for different workspaces.\r\n\r\nJust like @DanTup has described, this value is not available to the terminal.\r\nThe user could use the `terminal.integrated.env...` setting to add the GOPATH, but the cons of this are\r\nthat they will have to do this for each workspace that has a different GOPATH. (That's what we wanted to avoid in the first place)\r\n\r\nThere are 2 possible solutions for this:\r\n- An API to let extensions update the env variables used by the terminals. This is currently possible if the terminal is created by the extension itself, but not for terminals created by the user.\r\n- Or allow resolving of env var in settings. Note that the env var in this case should be from the process where the extension runs and not the renderer, other wise the point is moot, because extensions cannot update env var of the renderer process\r\n\r\n\r\n",
      "user":"ramya-rao-a"
    },
    {
      "comment":"> Or allow resolving of env var in settings\r\n\r\nThis option only really works for an env var that is very specific, like `GOPATH`, but wouldn't work for the case where it's `PATH` that we want to supply (since we'd get a ton of junk).",
      "user":"DanTup"
    },
    {
      "comment":"So if we were to support something like this:\r\n\r\n```js\r\n{\r\n  \"terminal.integrated.env.additionalPaths\": [\r\n    // ...\r\n  ]\r\n}\r\n```\r\n\r\nIs the way you see it working by checking if the path exists on the fs and adding it to the start of the path if so? So this:\r\n\r\n```js\r\n{\r\n  \"terminal.integrated.env.additionalPaths\": [\r\n    \"C:\\\\windows\\dart\",\r\n    \"/home/me/dart\",\r\n  ]\r\n}\r\n```\r\n\r\nWould lead to this on Windows: `C:\\\\windows\\dart;...`\r\nAnd this on Unix: `/home/me/dart:...`\r\n\r\nThis doesn't really solve the problem of you needing to maintain 2 settings though right?",
      "user":"Tyriar"
    },
    {
      "comment":"We've had something similar in the Python extension.\r\nThe requirement is for the Python executable to be available in the terminal (its all about paths again).\r\nOne can have multiple python executables on their PC. The solution we implemented was as follows:\r\n* Provide a custom command in the command palette `Python: Create Terminal`\r\n* Identify the python environment that needs to be used\r\n* Locate the corresponding activation scripts (bash, batch, powershell, etc)\r\n* Create a new terminal\r\n* Execute the above (necessary) scripts\r\n* Now the necessary environment variables (paths) are set\r\n\r\nSo, we solved this by taking control over the creation of the terminal and sending custom commands.",
      "user":"DonJayamanne"
    },
    {
      "comment":"@Tyriar \r\n\r\n> So if we were to support something like this (`\"terminal.integrated.env.additionalPaths\"`)\r\n\r\nThat would be great; though I think avoiding terminal in the setting name would be better (to show it's designed for use by other tooling and not only the terminal).\r\n\r\n> This doesn't really solve the problem of you needing to maintain 2 settings though right?\r\n\r\nIt does, because we'd read that setting and use it to search for the SDK. When the user users our SDK-picker, we'll add the new SDK path to the front of that array (and remove the old one if it exists).\r\n\r\n@DonJayamanne \r\n\r\n> So, we solved this by taking control over the creation of the terminal and sending custom commands.\r\n\r\nBut presumably you can't get in between the new terminal options in the Code UI, so the users can still create terminals without your `PATH`, right?",
      "user":"DanTup"
    },
    {
      "comment":"Ok I just read through this one again. The underlying problem is that language extensions want a way to be able to add arbitrary environment variables (or append/prepend to existing ones) to all terminals created but they cannot intercept the creation. I think only the terminal\r\n\r\nI'm proposing we extend `terminal.integrated.env.<platform>` as https://github.com/microsoft/vscode/issues/46696#issuecomment-376835091 suggested to support strings as well as objects that give more fine-grained control:\r\n\r\n```json\r\n{\r\n  \"terminal.integrated.env.windows\": {\r\n    \"GOPATH\": \"/some/path\",\r\n    \"PATH\": {\r\n      \"append\": \";/another/path\",\r\n      \"prepend\": \"/some/path;\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nNote that `terminal.integrated.env` will give a workspace shell permissions dialog when the first terminal is created just like with `shell` and `shellArgs`.\r\n\r\n> The setting isn't specific to the extension or the terminal, it's a generic way for the user to tell anyone that cares that they have some preferred paths for this workspace that should be searched before PATH.\r\n\r\nI disagree with this, this should be specific to the terminal and not be used by any other feature in VS Code as extensions can currently control everything AFAIK. Please correct me if I'm wrong.\r\n\r\n---\r\n\r\nOpening this up to PRs, feedback is always welcome.",
      "user":"Tyriar"
    },
    {
      "comment":"FYI @alexr00 since task's `\"env\"` is very similar to the terminals.",
      "user":"Tyriar"
    },
    {
      "comment":"> The underlying problem is that language extensions want a way to be able to add arbitrary environment variables (or append/prepend to existing ones) to all terminals created but they cannot intercept the creation.\r\n\r\nCorrect. The issue is that users change the SDK inside the VS Code settings, and then try to run commands in the terminal and they seem to be using \"the old SDK\" and not the one they just selected.\r\n\r\n> > The setting isn't specific to the extension or the terminal, it's a generic way for the user to tell anyone that cares that they have some preferred paths for this workspace that should be searched before PATH.\r\n> \r\n> I disagree with this, this should be specific to the terminal and not be used by any other feature\r\n\r\nMy point is that we want *one* place to put a path that will be used for:\r\n\r\n1. The Terminal\r\n2. The extension finding its SDK\r\n\r\nIt does not make sense to put something inside a setting called `terminal.integrated` and say that's how an extension finds it SDK, and it does not make the sense to tell the user they need to set the SDK both in the extension settings and in these settings (nor does it make much sense for the extension to be trying to update this value as the SDK is changed IMO). This is what I said at https://github.com/microsoft/vscode/issues/46696#issuecomment-378558777. The request is that there is a *single place* a user can put a PATH that will be used both by the terminal and the extension (which is why I proposed a generic non-terminal-specific name).",
      "user":"DanTup"
    },
    {
      "comment":"@DanTup you as the extension can choose where the source of truth for the SDK is (either the workspace setting or some internal storage), but the setting itself only affects the terminal in vscode core which is why it has that namespace.",
      "user":"Tyriar"
    },
    {
      "comment":"@Tyriar Right, but it's weird to say \"this setting that has terminal in its name is how you set the SDK for the extension\" - that would make it not a terminal-specific setting. Having the extension overwrite it also feels weird (and dangerous - what do we do if there are already values that don't exactly match the SDK we're switching away from?).\r\n\r\nIf I understand correctly, TS has this same issue - you can click on the status bar to switch between the VS Code-shipped version of TS, or the package.json version. However running `tsc` from the terminal will always use the version from `PATH`. This is essentially how Dart works (https://dartcode.org/docs/quickly-switching-between-sdk-versions/). The users are confused because when they run `dart`/`flutter` in the terminal it doesn't match the one they've selected and is being used by the editor.",
      "user":"DanTup"
    },
    {
      "comment":"@DanTup if I were you I would use a status bar item like TS does and then make sure (periodically, on load?) that the workspace setting is the same. The source of truth for the workspace should then be either a workspace setting, pulled from some standard Dart file (if that's a thing, like package.json in TS) or stored internally to your extension.",
      "user":"Tyriar"
    },
    {
      "comment":"For TS it's a little special as we always use whatever VS Code ships with (typically the latest version) as that gives the best language support. If you need anything else there is a setting that you can set, I think \"using the workspace TS version\" remembers that in the extension's storage, not settings.",
      "user":"Tyriar"
    },
    {
      "comment":"> if I were you I would use a status bar item like TS does and then make sure (periodically, on load?) that the workspace setting is the same\r\n\r\nI do have a status bar action for changing SDKs (as shown in the page linked above). But \"periodically checking they're the same\" doesn't really solve the problem. What do I do if they're not the same? What do I do when the user changes the SDK in the status bar, should I just overwrite whatever is in the `terminal.integrated` setting? This feels like a very sub-optimal way to handle this, and there are several languages mentioned above as wanting this (Dart, Go, Python) and TypeScript also seems to have the same quirk.",
      "user":"DanTup"
    },
    {
      "comment":"The extension could watch for config changes and either warn or switch sdks automatically when the setting changed?",
      "user":"Tyriar"
    },
    {
      "comment":"@Tyriar right, but above you said\r\n\r\n> I disagree with this, this should be specific to the terminal and not be used by any other feature \r\n\r\nNow you're suggesting that extensions should read this value and use it when selecting SDKs.. this feels a bit weird.",
      "user":"DanTup"
    },
    {
      "comment":"@DanTup the setting stands on its own without extensions, and all it does it change things in the terminal so it must live in the terminal namespace. It just happens to also help solve problems for extensions. If it was used by another component inside vscode core then it would make sense to change the namespace to something more generic.",
      "user":"Tyriar"
    },
    {
      "comment":"> and all it does it change things in the terminal\r\n\r\nThat's not true if extensions start using it for deciding which SDK to use. I think it's confusing to users that setting terminal settings might change things in the editor. This request was specifically about having an option that was very clearly additional `PATH`s for a workspace and very simple for extensions to read.\r\n\r\nI wonder if I could just use `sendText()` on the terminal to set the path (at creation, and when the user changes SDK)? ðŸ¤”",
      "user":"DanTup"
    },
    {
      "comment":"> That's not true if extensions start using it for deciding which SDK to use. I think it's confusing to users that setting terminal settings might change things in the editor. This request was specifically about having an option that was very clearly additional PATHs for a workspace and very simple for extensions to read.\r\n\r\nYeah I get that, but since literally the only thing it does in vscode core is affect the terminal, it should live in the terminal namespace. `dart.sdkPath` should really be the source of truth, and you just track `terminal.integrated.env` to make sure if it changes you can react.\r\n\r\n> I wonder if I could just use sendText() on the terminal to set the path (at creation, and when the user changes SDK)?\r\n\r\nYou can do that but there are several issues with that approach which the Python team have hit like weird timing issues (some proc swallowing the text sometimes), detecting different shells and setting environment in the various different ways, etc. it would be far far better if it could be done as part of the terminal's environment setup.",
      "user":"Tyriar"
    },
    {
      "comment":"Since #83593 was closed in favor of this issue, I'd like to ensure the needs from that issue are also captured here. Reading through this issue, it seems to have more complex requirements or requires more complex design than what I'm looking for. What I'm asking for is hopefully simpler: the capability offered by the [`DebugConfigurationProvider.resolveDebugConfiguration`](https://code.visualstudio.com/api/references/vscode-api#DebugConfigurationProvider) method, but extended to terminal options and task configuration.\r\n\r\nFor example, for terminals there might a be a similar `TerminalOptionsResolver.resolveTerminalOptions` method and ability to register a resolver that allows extensions to modify the terminal options used when anybody calls the `vscode.window.createTerminal` method. For tasks, there might be a new optional method on [`TaskProvider`](https://code.visualstudio.com/api/references/vscode-api#TaskProvider) like `preResolveTask` that is given a `Task` that is just about to run so it can be arbitrarily modified before it starts.\r\n\r\nThe specific requirements I have relates to injecting environment variables, but just like the debug configuration provider allows any part of the debug configuration to modified, it seems like it would make sense to allow the same flexibility for terminals and tasks. Note that I don't want anything in settings like `terminal.integrated.env`, placeholders or otherwise; this is purely something that lights up as a result of having an extension installed.",
      "user":"stepro"
    },
    {
      "comment":"Interested to hear your thoughts @DonJayamanne @DanTup ",
      "user":"Tyriar"
    },
    {
      "comment":"It sounds like that might only work for newly-opened terminals, so if the user already had a visible terminal when the extension was activated, it wouldn't apply?",
      "user":"DanTup"
    },
    {
      "comment":"It would depend on when the extension is activated, but yes, existing terminals couldn't be magically updated to include the environment variables.",
      "user":"stepro"
    },
    {
      "comment":"This would be a game changer for development of software using [Nix](nixos.org/nix).\r\n\r\nOne would typically define `shell.nix` with:\r\n\r\n```nix\r\n{ pkgs ? import (builtins.fetchTarball {\r\n    url = https://github.com/nixos/nixpkgs/archive/ca2ba44cab47767c8127d1c8633e2b581644eb8f.tar.gz;\r\n    sha256 = \"1jg7g6cfpw8qvma0y19kwyp549k1qyf11a5sg6hvn6awvmkny47v\";\r\n  }) {}\r\n}:\r\n\r\npkgs.mkShell {\r\n  name = \"dev-shell\";\r\n  buildInputs = [ pkgs.python37Full ];\r\n}\r\n```\r\n\r\nWhich pins `nixpkgs` distribution of Nix packages and then provides Python executable.\r\n\r\nTo activate, one needs to run `nix-shell`.\r\n\r\nVSCode would have to be generalized to **having executing a command that would provide an enviroment** for terminal and extensions, similar to `virtualenv` etc.\r\n\r\nThen each project could set that with `.vscode/settings.json`.\r\n\r\n",
      "user":"domenkozar"
    },
    {
      "comment":"@domenkozar Extensions do exist for [direnv](https://marketplace.visualstudio.com/items?itemName=Rubymaniac.vscode-direnv) and even [nix-shell](https://marketplace.visualstudio.com/items?itemName=arrterian.nix-env-selector).\r\nI've tried the direnv integration, but it cannot guarantee to complete before other commands are invoked, such as LSP servers, the terminal, etc.\r\n\r\nI think vscode should have an extension interface for hooking into every external command invocation, to provide the environments for the child processes. That will allow a nix/direnv/... extension to do its job correctly. An interface for suggesting restarts will make it even nicer, to avoid manual reloading, which users otherwise would have to learn.\r\n",
      "user":"roberth"
    },
    {
      "comment":"@roberth I'm quite sure the direnv extension will not work if you open a new terminal with the standard built-in command. It sets process.env in the extension host process, meaning any extension that launches a child process will get the environment variables, but the new terminal command (and I assume tasks as well) are started from the main VS Code process.\r\n\r\n+1 on the extension interface. In terms of restarts, the heavy hammer would be for the extension to prompt to reload the window - what would be even better is a vscode.window.restartTerminal method so an extension could prompt to restart specific terminals without reloading the window.",
      "user":"stepro"
    },
    {
      "comment":"> In terms of restarts, the heavy hammer would be for the extension to prompt to reload the window - what would be even better is a vscode.window.restartTerminal method so an extension could prompt to restart specific terminals without reloading the window.\r\n\r\nThis seems overkill to me, isn't it obvious to most users that terminals won't have access to Dart/Python for example if you had a terminal opened before installing the ext?",
      "user":"Tyriar"
    },
    {
      "comment":"@Tyriar yeah, it might be. Kind of like if I have a terminal open and install a new program on my laptop that requires a path update, I kind of know I need to restart my terminal.",
      "user":"stepro"
    },
    {
      "comment":"> This seems overkill to me, isn't it obvious to most users that terminals won't have access to Dart/Python for example if you had a terminal opened before installing the ext?\r\n\r\nBefore installing the extension it maybe, but I don't think that's the only issue with having extensions register something during activation because visible terminals may still initialise before the extension has registered when opening a project?",
      "user":"DanTup"
    },
    {
      "comment":"Something to also keep in mind with the extension provider approach is that terminals restored before the extension host is launched will not have the additional environment variables since the initial terminal is created before the extensions have been activated. We could have a package.json contribution to workaround this but that would mean blocking all terminal creation until the extension host has fully set up which I really would not like to see happen. The setting approach seems like the better one as it avoids this as well as provides more transparency to the user?",
      "user":"Tyriar"
    },
    {
      "comment":"I understand the focus on a settings approach here, but unless I misunderstand it I'm not sure it would work for my scenario. Here's an example of the kind of experience we're looking to enable:\r\n\r\n> A user opens a workspace for a web app that depends on a Mongo database consumes by the code through a `MONGO_CONNECTION_STRING` environment variable. The proposed extension detects that it needs to restore an instance of this database somewhere, which it does in the background. Once this is complete, it constructs the connection string to the database and notifies the user. At this point the user can run a task, launch the debugger, or open a terminal and automatically the MONGO_CONNECTION_STRING environment variable is populated with the value.\r\n\r\nUltimately, the value of the environment variable is not static but dynamic (in this case, it would contain a secret value that was dynamically pulled from somewhere external). So I don't see how this could be part of the user or workspace settings unless there was some placeholder, but then you're back to the problem of no terminal being allowed to open until the extension has been activated.",
      "user":"stepro"
    },
    {
      "comment":"I think you're right that a setting wouldn't work, but I don't think there's a single solution that can handle both of these:\r\n\r\n- Is available early enough to apply to all visible editors\r\n- Is able to be customised by an extension\r\n\r\nThis request was asking solve the first - allow the user a way to configure a `PATH` somewhere that will apply to built-in terminals and that extensions can also use for searching for SDKs. Essentially it's just like the user setting `PATH` on their system, except for a) that can't be done per-workspace and b) setting PATH on some OSes in a way that applies to Code is apparently hard (most people set them in terminal startup scripts which then work in the VS Code terminal but leaves them confused about why we say that they're not on `PATH` so the extension can't find them if they launched Code outside of the terminal).",
      "user":"DanTup"
    },
    {
      "comment":"> This request was asking solve the first - allow the user a way to configure a PATH somewhere that will apply to built-in terminals and that extensions can also use for searching for \r\n\r\nProviding the extension the ability to set PATH and other env variables that can be picked up by terminal, is something the python extension would love to have. We get around this by sending scripts to the terminal when ever a terminal opens (flaky however it's the only solution we have).",
      "user":"DonJayamanne"
    },
    {
      "comment":"@stepro I think you've convinced me with your approach and we should block terminal creation for extensions to be able to participate, it would need a contribution point though so that we know before the extension has activated that there are extensions that the terminal needs to block on and ask before launching.\r\n\r\n> This request was asking solve the first - allow the user a way to configure a PATH somewhere that will apply to built-in terminals and that extensions can also use for searching for SDKs.\r\n\r\n@DanTup I'm still pretty against this specifically, your extension should be the source of truth of the SDK and then use the resolve environment API whatever it ends up being whenever a terminal (+task/debug session?) gets launched.\r\n\r\n@DonJayamanne yeah sending text is awful but the only workaround right now.",
      "user":"Tyriar"
    },
    {
      "comment":"@alexr00 @weinand what do you think of the idea of having an extension environment contribution point that lets it resolve environments of processes launched by terminal, tasks and debug? This would allow Python, Dart, Go, etc. to inject the right SDK into PATH, set GOPATH, etc. instead of using the current bad workarounds which include sending text to the terminal and having separate commands to launch special terminals.",
      "user":"Tyriar"
    },
    {
      "comment":"@Tyriar \r\n\r\n> I'm still pretty against this specifically, your extension should be the source of truth of the SDK and then use the resolve environment API whatever it ends up being whenever a terminal (+task/debug session?) gets launched.\r\n\r\nYeah, that is my preference too. The original request here was because I assumed we'd never get an API that allows us to provide the path to a terminal programatically so the next best thing was to let the user specify the SDK path somewhere that both extension and VS Code would read.\r\n\r\n> it would need a contribution point though so that we know before the extension has activated that there are extensions that the terminal needs to block on and ask before launching\r\n\r\nWhat does this mean for an unactive extension that contributes? I wouldn't want the Dart extension being activated just because VS Code is creating a terminal if the user is working on a non-Dart project. IMO extensions are already activated way too eagerly - for ex. the C# extension often activates when I'm working on a non-C# project and then starts downloading dependencies - this behaviour is crazy and I wouldn't want Dart to start doing the same.\r\n\r\nThe SDK location can also change after a project is loaded (for example if a user adds a Flutter project to an existing workspace that only had Dart, we may now wish to add a Flutter extension - or the user could use a command to switch between SDKs). Would it be possible to notify VS Code that this has changed so the user can be warned that existing terminals may be using old paths (or give an option to quickly recreate them if they're not running processes?).",
      "user":"DanTup"
    },
    {
      "comment":"> What does this mean for an unactive extension that contributes? I wouldn't want the Dart extension being activated just because VS Code is creating a terminal if the user is working on a non-Dart project.\r\n\r\nGood question, this stuff is pretty new for me so I'd need to hear from people who know about it. Don't language extensions activate based on files within a workspace in which case everything would work out fine?",
      "user":"Tyriar"
    },
    {
      "comment":"Yeah, but they could also be activated later than the project is opened (and also I susepct a lot of things like workspaceContains are async). Eg. you could add a Dart file to an existing open project, or we could have onCommand activation events that let you trigger activation of the extension if it's not activated.\r\n\r\nThat's why I think an API that lets us tell VS Code the PATH has changed (rather than it only asking us) would help. I think it's easy for users to understand too - they change the SDK they're using in the status bar and VS Code prompts them to re-create terminals saying an extension changed a contributed path.",
      "user":"DanTup"
    },
    {
      "comment":"I often end up using the terminal before extensions are done activating _because_ it is available early. I would really rather not have it delayed by having to activate _any_ extensions. For example, the ts extension is slow to activate, which keeps the extension host busy, which leads to other extensions being slow to activate, which would finally lead to a delay in terminal availability even if ts isn't the extension contributing to the terminal path.\r\n\r\nIf you decide to go this contribution route, then I wouldn't delay terminal start up on it. Instead, any extensions that are already activated can contribute whatever path they want, and any terminals created after that point would pick it up.",
      "user":"alexr00"
    },
    {
      "comment":"> If you decide to go this contribution route, then I wouldn't delay terminal start up on it. Instead, any extensions that are already activated can contribute whatever path they want, and any terminals created after that point would pick it up.\r\n\r\nI get the delay argument... But then it's inconsistent and we get bugs reported about environments being different ðŸ¤” ",
      "user":"Tyriar"
    },
    {
      "comment":">  they change the SDK they're using in the status bar and VS Code prompts them to re-create terminals saying an extension changed a contributed path.\r\n\r\n@DanTup well if we did *not* delay activation you could still use a notification by checking if there are any `window.terminals` and prompt to recreate (or recreate automatically?)",
      "user":"Tyriar"
    },
    {
      "comment":"> well if we did *not* delay activation you could still use a notification by checking if there are any `window.terminals` and prompt to recreate (or recreate automatically?)\r\n\r\nSure, but it seems like something better done by Code than each extension implementing their own version of it (with a far more limited API). For example VS Code could do better than a notification (like a message across the top of the terminal), it (probably) knows better if a terminal is running a process (we don't want to terminate processes to re-create terminals) and the user could have a single setting to opt-out of these notifications (or auto-recreate or whatever).\r\n\r\nIf you don't delay, it seems like this situation will happen *a lot* (like every time you open a Dart/Flutter project, and any other languages that use this) so it should have a nice UX.",
      "user":"DanTup"
    },
    {
      "comment":"I'm assuming that the result of this will be some kind of new API like vscode.env.registerEnvironmentVariableProvider(...) that an extension would probably call during activation. Seems like VS Code could use the call to this method coming from an extension as a trigger to recognize that environment variables have changed and prompt the user to restart their terminals.\r\n\r\nSomething unrelated: could this environment variable contribution API be invoked per workspace root, so opening a terminal on one workspace root vs. another would result in different environment variables being contributed? This would be necessary for more complex versions of my scenario, where the code in folder 1 needs FOO=bar to run while the code in folder 2 needs BAR=baz to run.",
      "user":"stepro"
    },
    {
      "comment":"Thoughts?\r\n\r\n```ts\r\nexport interface EnvironmentVariableProvider {\r\n\t/**\r\n\t * Called every time a terminal (task?/debug?) is created.\r\n\t * \r\n\t * @param workspaceFolder The workspace folder if it exists\r\n\t * @param env The original environment\r\n\t */\r\n\tprovideEnvironmentVariables(\r\n\t  workspaceFolder: WorkspaceFolder | undefined,\r\n\t  env: { [key: string]: string | null }\r\n\t): ProviderResult<{ [key: string]: string | null }>;\r\n}\r\n\r\nexport namespace env {\r\n\t/**\r\n\t * Registers a new environment variable provider, if this happens after\r\n\t * termnals have already been created (eg. ext activation after launch, new\r\n\t * ext installs) a notification will show informing the user they might need\r\n\t * to restart their terminals.\r\n\t */\r\n\texport function registerEnvironmentVariableProvider(\r\n\t  provider: EnvironmentVariableProvider\r\n\t): Disposable;\r\n}\r\n```",
      "user":"Tyriar"
    },
    {
      "comment":"@stepro \r\n\r\n> Seems like VS Code could use the call to this method coming from an extension as a trigger to recognize that environment variables have changed and prompt the user to restart their terminals\r\n\r\nThat's fine for startup, but doesn't address the need of extensions changing these variables later (eg. the user selects a different SDK while they're working).\r\n\r\n@Tyriar \r\n\r\n> Thoughts?\r\n\r\nSeems reasonable to me - though doesn't seem to support them changing later. Could we have an event (eg. similar to `CodeLensProvider.onDidChangeCodeLenses`) we could fire too?",
      "user":"DanTup"
    },
    {
      "comment":"Oh, btw, what's the purpose of the `WorkspaceFolder` - couldn't the extension just as easily read that themselves? (I ask just because it's not clear what happens if it's a multi-root workspace and you open a terminal - it's not really tied to any folder)",
      "user":"DanTup"
    },
    {
      "comment":"I realize my previous comment around VS Code automatically determining that environment variables may have changed would actually not work well in my case, because I don't know the environment variables at activation time but rather only after certain commands have been invoked on the extension.\r\n\r\nMaybe a global method like `env.provideEnvironmentVariables()` would be more appropriate, as an extension's way of saying \"please update the set of environment variables for a given workspace folder and trigger a user notification that they changed\". This could be called by an extension at any time, with the understanding that from that point on terminals, tasks and debug launches in the context of the chosen workspace folder will receive these environment variables.",
      "user":"stepro"
    },
    {
      "comment":"> Oh, btw, what's the purpose of the WorkspaceFolder - couldn't the extension just as easily read that themselves? (I ask just because it's not clear what happens if it's a multi-root workspace and you open a terminal - it's not really tied to any folder)\r\n\r\nIsn't it the case that if you have a multi-root workspace and run the built-in \"Create new terminal\" command that it prompts you on which root folder you want to open the terminal?",
      "user":"stepro"
    },
    {
      "comment":"Oh yeah, you're right ðŸ™ˆ I've somehow never seen that before (though I only have a few multi-root workspaces, and tend to use the default terminal that's there when I open).",
      "user":"DanTup"
    },
    {
      "comment":"> Isn't it the case that if you have a multi-root workspace and run the built-in \"Create new terminal\" command that it prompts you on which root folder you want to open the terminal?\r\n\r\nYep, terminals could be created for roots or maybe without roots (eg. createTerminal with some random `string` path).\r\n\r\n> Seems reasonable to me - though doesn't seem to support them changing later. Could we have an event (eg. similar to CodeLensProvider.onDidChangeCodeLenses) we could fire too?\r\n\r\n> Maybe a global method like env.provideEnvironmentVariables() would be more appropriate, as an extension's way of saying \"please update the set of environment variables for a given workspace folder and trigger a user notification that they changed\". This could be called by an extension at any time, with the understanding that from that point on terminals, tasks and debug launches in the context of the chosen workspace folder will receive these environment variables.\r\n\r\nI was thinking of it more like you register the provider when you know you have environment variables to set, then that provider is called for every individual environment that needs to be set up; creating 2 terminals in a single workspace will result in 2 `provideEnvironmentVariables` calls.",
      "user":"Tyriar"
    },
    {
      "comment":"> I was thinking of it more like you register the provider when you know you have environment variables to set, then that provider is called for every individual environment that needs to be set up; creating 2 terminals in a single workspace will result in 2 provideEnvironmentVariables calls.\r\n\r\nThat would work for me, but only if I own when to show the notification to the user of when terminals need to be restarted, because VS Code won't know the right time to show the notification. My workflow is like this:\r\n\r\n- User invokes action on my extension;\r\n- My extension does some background work that result in figuring out some environment variables;\r\n- My extension tells the user the work is completed. It's at this point that those environment variables could actually be provided.\r\n\r\nAt no point here would VS Code know when to show a notification that \"environment variables changed; please restart terminals\". Only my extension knows that. @DanTup had the suggestion of an event callback that would be able to tell VS Code when the environment variables have changed. I'd need that kind of thing if we used a provider registration model.",
      "user":"stepro"
    },
    {
      "comment":"@stepro your extension would call `registerEnvironmentVariableProvider` at this point:\r\n\r\n> My extension tells the user the work is completed. It's at this point that those environment variables could actually be provided.\r\n\r\nIf/when a big change happens like an SDK change, you could dispose that provider and register a new one, resulting in a new notification?",
      "user":"Tyriar"
    },
    {
      "comment":"I suppose that's possible, but it seems pretty heavyweight. In my scenario it's not an SDK change. Say I've opened some folder representing a Node web application. That application depends on a `MONGO_CONNECTION_STRING` environment variable pointing to a valid, operational Mongo database. My extension detects this, spins up the Mongo database in the background, then tells the user when it's ready. At that point, the developer should be able to open a terminal, run tasks or debug, and this environment variable is provided and populated. If the user adds another dependency or changes the environment variable they are using to consume the Mongo database, the environment variables will change.\r\n\r\nThink of it kind of like opening package.json and adding a new Node package dependency, after which you might be prompted to run `npm install` again, but with the added complication that the consumption model is via environment variables, not via loading the installed module from a `node_modules` directory.",
      "user":"stepro"
    },
    {
      "comment":"> I was thinking of it more like you register the provider when you know you have environment variables to set, then that provider is called for every individual environment that needs to be set up\r\n\r\nAs mentioned above - this doesn't let us force the notification for existing terminals when the SDK changes.\r\n\r\n> you could dispose that provider and register a new one, resulting in a new notification?\r\n\r\nI think that would work - though having a different API to CodeLens for essentially the same purpose seems a bit strange. In Dart we also keep all of our providers in a list so we can manually dispose them for \"silent extension restarts\", so this would also make that a bit more clumsy (since we'd need to replace the provider in there if we do this, which means exposing that list to the code that changes the SDK, or firing an event, etc.).",
      "user":"DanTup"
    },
    {
      "comment":"With the event:\r\n\r\n```ts\r\nexport interface EnvironmentVariableProvider {\r\n\t/**\r\n\t * Called every time a terminal (task?/debug?) is created.\r\n\t * \r\n\t * @param workspaceFolder The workspace folder if it exists\r\n\t * @param env The original environment\r\n\t * @returns The whole environment (this could also be just changes and use { [key: string]: string | null }?)\r\n\t */\r\n\tprovideEnvironmentVariables(\r\n\t  workspaceFolder: WorkspaceFolder | undefined,\r\n\t  env: { [key: string]: string | undefined }\r\n\t): ProviderResult<{ [key: string]: string | undefined }>;\r\n\r\n\t/**\r\n\t * An optional event to signal that environment variables being provided\r\n\t * have changed, a notification will display if there are any terminals\r\n\t * for the matching workspace folder.\r\n\t */\r\n\tonDidUpdateEnvironmentVariables?: Event<WorkspaceFolder | undefined>;\r\n}\r\n\r\nexport namespace env {\r\n\texport function registerEnvironmentVariableProvider(\r\n\t  provider: EnvironmentVariableProvider\r\n\t): Disposable;\r\n}\r\n```",
      "user":"Tyriar"
    },
    {
      "comment":"Looks good to me.",
      "user":"stepro"
    },
    {
      "comment":"Looks good to me too. I'm slightly curious about the `null`s  in the `env`. Why not `undefined`?\r\n\r\nAlso, I think you should document whether the return value should be a whole new environment, or just values to lay over the top of/changes to the incoming value.",
      "user":"DanTup"
    },
    {
      "comment":"> Why not undefined?\r\n\r\n@DanTup fixed, I copied that type from `TerminalOptions.env` where null will delete variables.\r\n\r\n> Also, I think you should document whether the return value should be a whole new environment, or just values to lay over the top of/changes to the incoming value.\r\n\r\nMade a note in the comment",
      "user":"Tyriar"
    },
    {
      "comment":"> this could also be just changes and use { [key: string]: string | null }\r\n\r\nI don't think there's a big difference in the approaches, but if we return the whole environment there's no room for confusion over what unsets things (versus not changing them). Object spread makes it fairly terse to add/overwrite without needing to use `Object.assign`.\r\n\r\nLooks good to me though :-)\r\n\r\nOh, one final question.. The manipulations made here don't persist in any way do they? Eg. the second time you call `provideEnvironmentVariables` it will be provided with the same original env variables and not the output from the previous call? (I want to prepend onto `PATH` and it'd be weird if we keep adding to it on every SDK change).",
      "user":"DanTup"
    },
    {
      "comment":"> I don't think there's a big difference in the approaches\r\n\r\nI'm leaning towards returning the full object so the provider can just change it and return, or return `ProviderResult<void>` and force changing the object in place.\r\n\r\n> The manipulations made here don't persist in any way do they?\r\n\r\nEach call only affects a single terminal.",
      "user":"Tyriar"
    },
    {
      "comment":"> or return `ProviderResult<void>` and force changing the object in place\r\n\r\nWould returning `undefined` work for that too? (for ex. if you had conditions and just didn't return anything in the case you didn't have something to modify). It should be explicitly documented how this works - there are some other parts of the Code API where they pass objects and you return them (like `resolveCompletionItem`) and I often wonder whether mutating the original object is a reasonable thing to do. The more explicit the docs are, the less likely someone will interpret them one way and then get broken break because it wasn't part of the contract :-)",
      "user":"DanTup"
    },
    {
      "comment":"It seems like [direnv](https://direnv.net/) solves this exact problem. Unfortunately, it still leaves issues with environment inheritance that I'm trying to get resolved in #88718. Take a look and tell me what you think.",
      "user":"jacobisaliveandwell"
    },
    {
      "comment":"We discussed this proposal this morning in relation to a use case we have in js-debug (linked above). Some points of discussion were around:\r\n\r\n - How can we keep terminal opening fast? Right now opening the terminal doesn't rely on extension activation. In this world, we'd need to activate extensions to get the environment for the terminal.\r\n - What happens if an extension wants to change the terminal configuration?\r\n - How can we allow users to see how their environment gets modified and confirm they're OK with it?\r\n\r\n## Speed\r\n\r\nOne solution to this is allowing extensions to have the extension provide patches to the environment. In the API this could be chromed over like [the editor.edit API](https://github.com/microsoft/vscode/blob/536e8162081e68001e774158284a4fc1bdbdbeae/src/vs/vscode.d.ts#L1117-L1128):\r\n\r\n```ts\r\nexport interface EnvironmentVariableCollection {\r\n  /**\r\n   * Gets an environment variable for the current terminal. Any previous\r\n   * transformations (set, delete, etc.) will be reflected in the value\r\n   * returned from this method.\r\n   * @param key The environment variable to get, case insensitive on windows\r\n   * @returns The value of the variable, or null if unset\r\n   */\r\n  get(key: string): string | null;\r\n\r\n  /**\r\n   * Sets or overwrites an environment variable.\r\n   * @param key The environment variable to set, case insensitive on windows\r\n   * @param value The value of the environment variable\r\n   */\r\n  set(key: string, value: string): EnvironmentVariableCollection;\r\n\r\n  /**\r\n   * Removes a set environment variable.\r\n   * @param key The environment variable to unset, case insensitive on windows\r\n   */\r\n  delete(key: string): EnvironmentVariableCollection;\r\n\r\n  /**\r\n   * Appends text to the end of an environment variable. If the variable is\r\n   * not previous set, `valueIfNew` is used if provided.\r\n   * @param key The environment variable to update, case insensitive on windows\r\n   * @param value The value to append to the variable\r\n   * @param valueIfNew The value to set the variable to if there's no previous\r\n   * variable with that name.\r\n   */\r\n  append(key: string, value: string, valueIfNew?: string): EnvironmentVariableCollection;\r\n\r\n  /**\r\n   * Prepends text to the start of an environment variable. If the variable is\r\n   * not previous set, `valueIfNew` is used if provided.\r\n   * @param key The environment variable to update, case insensitive on windows\r\n   * @param value The value to prepend to the variable\r\n   * @param valueIfNew The value to set the variable to if there's no previous\r\n   * variable with that name.\r\n   */\r\n  prepend(key: string, value: string, valueIfNew?: string): EnvironmentVariableCollection;\r\n}\r\n\r\nexport interface EnvironmentVariableProvider {\r\n  /**\r\n   * Called every time a terminal (task?/debug?) is created.\r\n   * \r\n   * @param workspaceFolder The workspace folder if it exists\r\n   * @param env The original environment\r\n   * @returns The whole environment (this could also be just changes and use { [key: string]: string | null }?)\r\n   */\r\n  provideEnvironmentVariables(\r\n    workspaceFolder: WorkspaceFolder | undefined,\r\n    env: EnvironmentVariableCollection,\r\n  ): ProviderResult<EnvironmentVariableCollection>;\r\n\r\n  // ...\r\n}\r\n```\r\n\r\nWhat this would allow us to do is store the patch when creating new terminals, to avoid needing to loop through all extensions each time. We would also be able to store the patch between VS Code sessions to avoid needing to activate extensions before starting the terminal when a new window is created.\r\n\r\n## Confirmation\r\n\r\nThe first time a path-modifying extension is registered, we'll confirm with the user before providing its environment variables and continuing with terminal creation. This works very nicely with the 'patching' method given above: only the first launch of the terminal would be slow, but we will require user confirmation to apply the changes, which should hide the slowness.\r\n\r\n## Changing the Variables\r\n\r\nThere was a question around what happens when `onDidUpdateEnvironmentVariables` fires. We cannot safely update the environment variables in existing terminals automatically, but we also don't want users to have to manually close and reopen terminals when the environment changes. Also, when the environment changes, we want users to know whether the update is something they want to apply. \r\n\r\nOne way to approach this is to create some notification or button within the terminal which, when clicked, would send text to the terminal that applies the updated environment. For instance, if an extension wanted to prepend something new to the path, we would write `export PATH=\"/home/user/my/new/path:$PATH\"\\n`. In this approach, the extension could provide helpful text that could be shown alongside the button to avoid the need for a disruptive notification.\r\n\r\n```ts\r\n\r\nexport interface EnvironmentUpdateEvent {\r\n  /**\r\n   * Folder in which the environment variables should be updated, or undefined \r\n   * if it should be applied across all terminals. \r\n   */\r\n  folder?: WorkspaceFolder;\r\n\r\n  /**\r\n   * Message displayed to the user briefly describing why the environment was updated.\r\n   */\r\n  message?: string;\r\n}\r\n\r\nexport interface EnvironmentVariableProvider {\r\n  // ...\r\n\r\n  /**\r\n   * An optional event to signal that environment variables being provided\r\n   * have changed.\r\n   */\r\n  onDidUpdateEnvironmentVariables?: Event<EnvironmentUpdateEvent>;\r\n}\r\n```\r\n\r\ncc @kieferrm @roblourens ",
      "user":"connor4312"
    },
    {
      "comment":"If I understand correctly, I think this would work for me. Just to clarify I understand correctly:\r\n\r\n- This will not require extensions to be eagerly-activated\r\n- I can register a `EnvironmentVariableProvider` with a `provideEnvironmentVariables` that calls `prepend` to insert an additional `PATH` (using my existing SDK setting). This will be used for future terminals but existing terminals would also get a prompt that allows the user to approve injecting an `export` to update immediately.\r\n- I can also provide an `onDidUpdateEnvironmentVariables` event that I can call when the user changes the SDK using my command, triggering an immediate call to `provideEnvironmentVariables` to prompt/update as above.\r\n\r\nI also presume that the two args to `prepend` for `value` and `valueIfNew` are to allow delimeters, for example:\r\n\r\n```ts\r\nenv.prepend('PATH', `${dartSdkPath}${path.delimeter}`, dartSdkPath);\r\n```\r\n\r\nThanks!",
      "user":"DanTup"
    },
    {
      "comment":"All correct, Dan ðŸ™‚ ",
      "user":"connor4312"
    },
    {
      "comment":"> This will not require extensions to be eagerly-activated\r\n\r\n@connor4312 @DanTup until the extension is activated terminals will not have the changes to the environment though.\r\n\r\n> This works very nicely with the 'patching' method given above: only the first launch of the terminal would be slow, but we will require user confirmation to apply the changes, which should hide the slowness.\r\n\r\n@connor4312 this confirmation would only happen for the first time as after then it would need an opt-in. Do all successive launches just take extra time in this case for the initial provider(s) to respond?",
      "user":"Tyriar"
    },
    {
      "comment":">  until the extension is activated terminals will not have the changes to the environment though.\r\n\r\nI should have been more clear--the extension would only need to ever activate a single time. From that point forward we can store the patch it created and then apply that to future terminals.\r\n\r\n> this confirmation would only happen for the first time as after then it would need an opt-in. Do all successive launches just take extra time in this case for the initial provider(s) to respond?\r\n\r\nYes, the confirmation would only show the first time per extension. With the patch method, successive launches should not take noticeably more time.",
      "user":"connor4312"
    },
    {
      "comment":"@connor4312 what are the plans to invalidate the cache then? On reload an extension calls the provider again which replaces the results if it's different? What if an extension provides 2 `EnvironmentVariableProvider`s?\r\n\r\nDoes the terminal component then need to track whether the extensions have been disabled then? What if the extension is updated and no longer provides an `EnvironmentVariableProvider`? How would the terminal react to already activated patches when it discovers they are no longer valid?",
      "user":"Tyriar"
    },
    {
      "comment":"@connor4312 I was just drafting a proposal for exposing the ability to patch the environment. I'd like you to consider the scope beyond the terminal and simply expose patching the main process, which would in-turn take care of the terminal.\r\n\r\nMy specific use case is supporting `direnv` and similar tools, which commonly adjust `PATH` and has the downstream affect on extensions' ability to load tools.\r\n\r\nIf the concern is security, I don't think this is a meaningful threat vector, considering that the extensions are able to do so many other things. My understanding is that the process isolation is for stability and orthogonality.\r\n\r\nCurrently my workflow is to open my terminal, navigate to the path of my project, which in turn triggers the modification of my environment, then running `code .`. This must be done for each window. As well, the `File -> Open` set of commands becomes useless, since this environment is preserved in the reload. I was hoping to write a plugin to fix all this, but the inability to patch the parent process is a show stopper.",
      "user":"jacobisaliveandwell"
    },
    {
      "comment":"> what are the plans to invalidate the cache then?\r\n\r\nI think this would only be done by an extension firing `onDidUpdateEnvironmentVariables`--the environment variables they set are preserved until they tell us they're invalid.\r\n\r\n> On reload an extension calls the provider again which replaces the results if it's different? \r\n\r\nThe provider wouldn't ever be called except on the first load where we don't have environment variables from it yet, or if it indicated the variables it provided previously are invalid through the `onDidUpdateEnvironmentVariables` event. This means the extension needs to be active to invalid a cache, which I think is reasonable.\r\n\r\n> What if an extension provides 2 EnvironmentVariableProviders?\r\n\r\nMaybe we treat them as one provider for caching purposes? Calling a provider multiple times should be idempotent, at least between `onDidUpdateEnvironmentVariables` fires.\r\n\r\n> I'd like you to consider the scope beyond the terminal and simply expose patching the main process\r\n\r\nI'm familiar with direnv and use it as well; at least within the scope of the terminal, I think this proposal works for direnv-like functionality. What's the use case for patching the main process?",
      "user":"connor4312"
    },
    {
      "comment":"> I think this would only be done by an extension firing onDidUpdateEnvironmentVariables--the environment variables they set are preserved until they tell us they're invalid.\r\n\r\n@connor4312 this sounds risky, the provider needs to be instantiated on every window reload anyway. It seems really weird to expect an extension on start up to register the provider and then immediately fire `onDidUpdateEnvironmentVariables` because VS Code caches the old result across reloads. I'm not aware of any other APIs work like this?\r\n\r\n> I'd like you to consider the scope beyond the terminal and simply expose patching the main process\r\n\r\n@jacobisaliveandwell by main process I'm assuming you mean the renderer(window) process? The actual main process is the shared one that created the renderer processes. It's not as simple as that anyway as sometimes terminal environments are not derived from that process. Catching all the cases where you would need the patched environment and making sure they are covered in thee above proposal would be a better option than messing with VS Code's environment.",
      "user":"Tyriar"
    },
    {
      "comment":"> It seems really weird to expect an extension on start up to register the provider and then immediately fire onDidUpdateEnvironmentVariables because VS Code caches the old result across reloads\r\n\r\nI'm curious how often this would be needed. For js-debug and Dan's use case, I think we're okay to reuse the environment across sessions/until some other user interaction happens.",
      "user":"connor4312"
    },
    {
      "comment":"@connor4312 I'm pretty bad at remembering examples, but one that came up this morning: `.envrc` contains a modification to `PYTHONPATH` that in-turn would modify the way the Python Extension searches for modules.",
      "user":"jacobisaliveandwell"
    },
    {
      "comment":"What does the API look like from an extension's point of view (e.g. a language client depends on environment variables from the EnvironmentVariableProvider)?\r\n\r\n - will there is be an API endpoint you can call to register your extension so that it can receive notifications?\r\n - message prompts: are these up to each extension to handle individually? If one has three extensions which all depend on EnvironmentVariableProvider updates, it's okay for each one to prompt to reload, or will it be prompt overload? Maybe at a certain point, asking to reload the window makes more sense?\r\n\r\nI'm very much new to VSCode (and Typescript), but I did a little bit of scoping of what an environment variable provider feature might look like for direnv (based on the proposal in December), see https://github.com/fiadliel/direnv2/blob/master/src/DirenvEnvironmentVariableProvider.ts\r\nAnd then a modification to an existing plugin to use it: https://github.com/fiadliel/ghcide/commit/d1c6b97b6ca2a4ce8980dcac7c56f591128b4479\r\nI hope this shows the kind of use case that I'd like to use this for, so I hope it can ðŸ˜„ ",
      "user":"fiadliel"
    },
    {
      "comment":"@Tyriar \r\n\r\n> until the extension is activated terminals will not have the changes to the environment though.\r\n\r\nYep, understood. That's fine for me - if a user is typing `dart` or `flutter` in the terminal it's very likely they'll have opened a Dart/Flutter file/project causing the extension to activate.\r\n\r\nI specifically *don't* want the extension to be activated at startup. I'm forever uninstall extensions that eagerly activate and start downloading SDKs or spawning language servers when I'm not using them (there are many open issues about these kinds of problems) and I don't want to be part of that problem :-)\r\n\r\n",
      "user":"DanTup"
    },
    {
      "comment":"@connor4312 Another use case today: I need the `JAVA_HOME` variable, set by `jenv` for the Java and Maven extensions to use the correct SDK.",
      "user":"jacobisaliveandwell"
    },
    {
      "comment":"@Tyriar Interesting. I was not aware that the structure was that complex. I naively assumed the main process was tasked with launching any subprocesses that aren't run within an \"extension host\". I 100% defer to you all for implementation, but this would be amazing to finally solve.\r\n\r\nEdit: I dug around and understand better why this is so difficult.",
      "user":"jacobisaliveandwell"
    },
    {
      "comment":"Feedback from API call:\r\n\r\n- Caching is novel and feels dangerous\r\n- Provider model feels odd\r\n- \\*Try basing API on diagnostics collection instead of provider?\r\n- \\*Opt-in environment entries individually as persistent across reloads?\r\n- Two methods; update temp and update persistent?\r\n- Wait on extension if entry in package.json for this workspace type?\r\n\r\n\\* These are the next steps",
      "user":"Tyriar"
    },
    {
      "comment":"@Tyriar I'd still like to press for the scope to also include the ability for an extension to modify environment variables for other extensions. I've given a few examples of why in this ticket.",
      "user":"jacobisaliveandwell"
    },
    {
      "comment":"The question I have around the diagnostic collection is how the extension manages any previous or cached state. Say I have an `nvm` plugin and I want to add the binaries folder for the current install to the terminal, I'd do something like this:\r\n\r\n```\r\nconst vars = vscode.window.getTerminalVariableCollection();\r\nvars.append('PATH', nodeBinaries, `;${nodeBinaries}`);\r\n```\r\n\r\nWhat happens if those variables were cached from a previous version? If we reuse them, because I'm appending, the old folder would be before my newly-appended folder and would take priority. The alternative is getting a new collection each time we call the 'create collection' method and clearing any previously set variables. Which could work, it's just an side effect that might be surprising to extension authors. I think a provider makes it a bit more clear what's happening and defines the lifecycle in a tighter way.\r\n\r\nAside from that, I think having a temp versus persistent update would definitely be a good thing.",
      "user":"connor4312"
    },
    {
      "comment":"@jacobisaliveandwell while a direnv extension would work out fine, I think what you're after is out of scope of this feature request. You want the Python (or any language ext) to know about direnv's environment changes which would require the Python extension to depend on the Direnv extension, the Python extension maintains its own view of the world of what the current SDK is so it would need to be aware of direnv. Plus I think you want the API to modify the actual extension host's environment which is not what this is about, it's only about the terminal and tasks.\r\n\r\n---\r\n\r\n> What happens if those variables were cached from a previous version? If we reuse them, because I'm appending, the old folder would be before my newly-appended folder and would take priority. \r\n\r\nI would think that one extension can only append once per environment variable so the previous one would be overridden?\r\n\r\n```ts\r\n// This\r\nc.prepend('PATH', 'JAVA_HOME=foo;SOMETHING=bar;');\r\n\r\n// Not this\r\nc.prepend('PATH', 'JAVA_HOME=foo;');\r\nc.prepend('PATH', 'SOMETHING=bar;');\r\n```\r\n\r\n> The alternative is getting a new collection each time we call the 'create collection' method and clearing any previously set variables.\r\n\r\nThis also works, I haven't looked at diagnostics yet but will update with a new proposal probably this week before I start implementing.",
      "user":"Tyriar"
    },
    {
      "comment":"@Tyriar Understood. I'll open another issue.",
      "user":"jacobisaliveandwell"
    },
    {
      "comment":"> I would think that one extension can only append once per environment variable so the previous one would be overridden?\r\n\r\nThat behavior would be kind of surprising to me as an extension author. I could easily image doing something like\r\n\r\n```js\r\nc.prepend('PATH', `~/sdk/${version}/bin;`);\r\nif (version < 123) {\r\n  c.prepend('PATH', `~/sdk/${version}/legacy-additional-bin/path;`);\r\n}\r\n```\r\n\r\nin my code and wondering why it doesn't work",
      "user":"connor4312"
    },
    {
      "comment":"Here's my go at the API inspired by `DiagnosticsCollection`:\r\n\r\n```ts\r\nexport enum EnvironmentVariableMutatorType {\r\n\t/**\r\n\t * Replace the variable's existing value.\r\n\t */\r\n\tReplace = 1,\r\n\t/**\r\n\t * Append to the end of the variable's existing value.\r\n\t */\r\n\tAppend = 2,\r\n\t/**\r\n\t * Prepend to the start of the variable's existing value.\r\n\t */\r\n\tPrepend = 3\r\n}\r\n\r\nexport interface EnvironmentVariableMutator {\r\n\t/**\r\n\t * The type of mutation that will occur to the variable.\r\n\t */\r\n\treadonly type: EnvironmentVariableMutatorType;\r\n\t\r\n\t/**\r\n\t * The value to use for the variable.\r\n\t */\r\n\treadonly value: string;\r\n\r\n\t/**\r\n\t * @type Default is Replace\r\n\t */\r\n\tconstructor(value: string, type?: EnvironmentVariableMutatorType);\r\n}\r\n\r\nexport interface EnvironmentVariableCollection {\r\n\tset(variable: string, mutator: EnvironmentVariableMutator): void;\r\n\tget(variable: string): EnvironmentVariableMutator | undefined;\r\n\tforEach(callback: (variable: string, diagnostics: EnvironmentVariableMutator, collection: EnvironmentVariableCollection) => any, thisArg?: any): void;\r\n\tdelete(variable: string): void;\r\n\tclear(): void;\r\n\tdispose(): void;\r\n}\r\n\r\nexport interface window {\r\n\t/**\r\n\t * Creates an environment variable collection for this workspace, enabling\r\n\t * changes to terminal environment variables. Creating an collection will\r\n\t * replace any existing collections for this workspace.\r\n\t * @param persistent Whether the collection is cached for the workspace across\r\n\t * window reloads. When true the collection will be active immediately such\r\n\t * that terminal creation does not need to be blocked on extension activation,\r\n\t * to collection from previous sessions can be fetched using\r\n\t * `getEnvironmentVariableCollection`. The collection will be invalidated by\r\n\t * uninstalling the extension or by creating a new one. Defaults to false.\r\n\t */\r\n\tcreateEnvironmentVariableCollection(persistent?: boolean): EnvironmentVariableCollection;\r\n\r\n\t/**\r\n\t * Gets the environment variable collection for this extension and workspace,\r\n\t * if any.\r\n\t */\r\n\tgetEnvironmentVariableCollection(): EnvironmentVariableCollection | undefined;\r\n}\r\n```\r\n\r\nExample usage:\r\n\r\n```ts\r\n// Fetch existing collection if available\r\nconst collection = window.getEnvironmentVariableCollection() || window.createEnvironmentVariableCollection(true);\r\ncollection.set('PATH', new EnvironmentVariableMutator('/foo/bar:', EnvironmentVariableMutatorType.Prepend);\r\ncollection.set('JAVA_HOME', new EnvironmentVariableMutator('/foo/baz');\r\n// ~1 second after a change occurs the terminal will diff the collection to see\r\n// if the stale indicator would need to be displayed. This delay is since each\r\n// individual `set` will send their own async messages to the renderer\r\n```\r\n\r\nCurrent design decisions:\r\n\r\n- Collections are unique per workspace and per environment\r\n- Since collections will only get cached for a workspace, the first time a workspace is opened may result in a restored terminal with a stale environment\r\n- There is no event in this design, my thinking is we could have some button near the terminal that would indicate the environment may be stale which could list environment variables that an extension wants to change when hovered. For example:\r\n\r\n    > The extension ${name} wants to change this terminals environment:\r\n    >\r\n    > - Prepend $PATH with '/foo/bar:'\r\n    > - Replace $JAVA_HOME with '/foo/baz'\r\n    >\r\n    > Click this button to send export variable shell commands to the terminal.\r\n\r\n   Perhaps an \"A=B\" or \"A=\" icon in the terminal panel could do this (similar to the \"Aa\" match case icon)? The status bar could also work but would be new territory for the terminal.\r\n- The initial design had a name for the collection like `DiagnosticCollection` but since it makes sense for them to be unique per extension anyway it didn't seem useful and complicated things.\r\n\r\nQuestions:\r\n\r\n1. Should we prefix the API with \"Terminal\"?\r\n2. Is `getEnvironmentVariableCollection` needed? Should we merge create and get, otherwise `window.getEnvironmentVariableCollection() || window.createEnvironmentVariableCollection(true)` will be a common pattern.\r\n3. We don't use Map anywhere right now in the API but that's what an EnvironmentVariableCollection is, it could just as easily be this if we wanted to go that route:\r\n\r\n   ```ts\r\n   // Would need some other way to dispose it\r\n   createEnvironmentVariableCollection(persistent?: boolean): Map<string, EnvironmentVariableMutator>;\r\n   ```\r\n\r\n   @jrieken On a similar note, we could also make `DiagnosticCollection` inherit from a VS Code \"Disposable Map\" such that they share an interface without causing any breaking changes:\r\n\r\n   ```ts\r\n   export interface DiagnosticCollection extends DisposableMap<Uri, ReadonlyArray<Diagnostic>> {\r\n   \treadonly name: string;\r\n   }\r\n   \r\n   export interface EnvironmentVariableCollection extends DisposableMap<string, EnvironmentVariableMutator> {\r\n   }\r\n   \r\n   export interface DisposableMap<K, V> {\r\n   \tset(key: K, diagnostics: V | undefined): void;\r\n   \tset(entries: ReadonlyArray<[K, V | undefined]>): void;\r\n   \tdelete(key: K): void;\r\n   \tclear(): void;\r\n   \tforEach(callback: (key: K, diagnostics: V, collection: DisposableMap<K, V>) => any, thisArg?: any): void;\r\n   \tget(key: K): V | undefined;\r\n   \thas(key: K): boolean;\r\n   \tdispose(): void;\r\n   }\r\n   ```",
      "user":"Tyriar"
    },
    {
      "comment":"> EnvironmentVariableMutatorType.Prepend/Append\r\n\r\nMaybe we want to support an optional `delimiter` string that gets added if it's already set? I don't _think_ hanging delimiters in the PATH specifically would cause any issues, not sure if there are cases where it would be necessary.\r\n\r\n> There is no event in this design, my thinking is we could have some button near the terminal that would indicate the environment may be stale which could list environment variables that an extension wants to change when hovered\r\n\r\nI think this is fine, since the extension is now telling VS Code when it changes the variables, rather than asking to change them. The one concern I have is how VS Code will know that a set of variables is ready to go. For example, if my extension does something like\r\n\r\n```js\r\nconst vars = vscode.window.createEnvironmentVariableCollection();\r\n// if we prepended to the PATH previous, VS Code will see that mutation as being cleared\r\nconst nvmBin = await lookupNvmBinaryDir();\r\nvars.set('PATH', new EnvironmentVariableMutator(`${nvmBin}:`, EnvironmentVariableMutatorType.Prepend);\r\n// and now we have a new mutation in the map\r\n```\r\n\r\nWe'd need to know to wait for the \"await\" before letting the user know that X extension wants to change the environment variables in the terminal. We could tell authors to only use the collection synchronously but this seems like a footgun--I'd rather the API be impossible to use incorrectly, as much as we can ðŸ™‚ \r\n\r\n> Should we prefix the API with \"Terminal\"?\r\n\r\nðŸ‘ \r\n\r\n> Is getEnvironmentVariableCollection needed?\r\n\r\nWith this pattern API, I don't think so. And it's probably good to not encourage people to use that: ideally they would not derive their mutations from the current environment variables, since those variables might change and functionally invalidate a persisted set of mutations.\r\n\r\n> We don't use Map anywhere right now in the API but that's what an EnvironmentVariableCollection is, it could just as easily be this if we wanted to go that route\r\n\r\nMaking it a Map brings in quite a few more APIs that we may not want to expose. For example, we probably would not want to let extensions `clear()` all the environment variables.",
      "user":"connor4312"
    },
    {
      "comment":"> Maybe we want to support an optional delimiter string that gets added if it's already set? I don't think hanging delimiters in the PATH specifically would cause any issues, not sure if there are cases where it would be necessary.\r\n\r\nI think the delimeter is best left up to the extension, otherwise it would behave differently for `$PATH` and only `$PATH`, making it inconsistent and harder to understand?\r\n\r\n> The one concern I have is how VS Code will know that a set of variables is ready to go.\r\n\r\nThe idea behind the button is that if this does happen, it doesn't really matter much as it just influences the button showing, its tooltip and its action. So the worst things that could happen are:\r\n\r\n- A user to reads the tooltip and click and it would add an additional variable which doesn't really matter imo as they're printed on screen.\r\n- The user clicks the button to add variables and it shows up again\r\n\r\nThe more likely case however would be that they're all set before the user can move the mouse to the button and wait for the tooltip.\r\n\r\n> Making it a Map brings in quite a few more APIs that we may not want to expose. For example, we probably would not want to let extensions clear() all the environment variables.\r\n\r\nAllowing the extension author to easily start from a clear slate easily without re-creating the collection seems like a good thing, plus it's all just consistent with `DiagnosticCollection`. Same with `foreach`, there needs to be some way of getting all mutators or to fetch a `ReadonlyArray` of them.",
      "user":"Tyriar"
    },
    {
      "comment":"> I think the delimeter is best left up to the extension, otherwise it would behave differently for $PATH and only $PATH, making it inconsistent and harder to understand?\r\n\r\nI mean something explicit, e.g. a third argument:\r\n\r\n```\r\nnew EnvironmentVariableMutator(nvmBin, EnvironmentVariableMutatorType.Prepend, ':');\r\n// sets to `nvmBin` if empty, prepends `nvmBin:` if existent\r\n```\r\n\r\n> The more likely case however would be that they're all set before the user can move the mouse to the button and wait for the tooltip.\r\n\r\nYea, that's true, but there might be a long tail where that isn't the case (e.g. if someone does some file i/o that is actually a network share). The proposal I had above was somewhat inspired by the `TextEditorEdit` API, which is similar in that it allows an assortment of mutations with a strongly-controlled lifecycle.\r\n\r\n> Allowing the extension author to easily start from a clear slate easily without re-creating the collection seems like a good thing, plus it's all just consistent with DiagnosticCollection. Same with foreach, there needs to be some way of getting all mutators or to fetch a ReadonlyArray of them.\r\n\r\nAh, I see. I'd assumed that the map would have all ambient environment variables, but this way seems better ðŸ‘ ",
      "user":"connor4312"
    },
    {
      "comment":"> @jrieken On a similar note, we could also make DiagnosticCollection inherit from a VS Code \"Disposable Map\" such that they share an interface\r\n\r\nI am generally not a big fan of inheritance and for `vscode.d.ts` esp. not because IMO it hinders readability because it breaks the reading-flow. \r\n\r\n> The initial design had a name for the collection like DiagnosticCollection but since it makes sense for them to be unique per extension anyway it didn't seem useful and complicated things.\r\n\r\nWhat's the reason for having a collection per extension and not one shared collection? Do you want fine-grained control, e.g if extension A and B both add variable `foo` should deletion from B's collection \"unshadow\" A's value of `foo`? \r\n\r\n> plus it's all just consistent with DiagnosticCollection. Same with foreach, there needs to be some way of getting all mutators or to fetch a ReadonlyArray of them.\r\n\r\nI am not sure that env variables and collections are that equal. Env variables merge with overwriting, whereas diagnostics merge without overwriting. We have things like `clear` so that an extension can clean-up when deactivating or when closing a project, not sure I see an analogy with env-variables. ",
      "user":"jrieken"
    },
    {
      "comment":"@Tyriar \r\n\r\n> Since collections will only get cached for a workspace, the first time a workspace is opened may result in a restored terminal with a stale environment\r\n\r\nI'm not sure I fully understand this - does it mean the very first time you open any specific project, the applied SDK path would not be applied (until the user interacts with some UI designed to reload)? This might get a bit frustrating if users feel that every time they create a new project they have go to and \"fix\" the terminal.\r\n\r\nIf the cache is shared (eg. the terminal would load with the SDK path they'd set from another workspace), then that wouldn't be an issue - but I'm not sure if that's what you mean (since I'm not sure what the limitation is in that case).",
      "user":"DanTup"
    },
    {
      "comment":"> I am generally not a big fan of inheritance and for vscode.d.ts esp. not because IMO it hinders readability because it breaks the reading-flow.\r\n\r\n@jrieken np, we can just copy the interface instead.\r\n\r\n> What's the reason for having a collection per extension and not one shared collection? Do you want fine-grained control, e.g if extension A and B both add variable foo should deletion from B's collection \"unshadow\" A's value of foo?\r\n\r\nNot sure what \"unshadow\" means, but managing a shared collection feels like it would run into weird issues. Currently an extension would manage it's own collection and not need to worry about re-checking to see if something is set. Resolving conflicts is then up to the core to resolve and we simply don't inform extensions about these with the current proposal.\r\n\r\nWhat would happen if `clear` is called to give extension B a clear slate? It would clear out extension A's variables without informing it?\r\n\r\n> I am not sure that env variables and collections are that equal. Env variables merge with overwriting, whereas diagnostics merge without overwriting. We have things like clear so that an extension can clean-up when deactivating or when closing a project, not sure I see an analogy with env-variables.\r\n\r\nMy main point here was that if an extension is managing a set of something, it should be able to iterate over the items in some way to see what was set. This is not mandatory as they could just clear before every one and/or set on every key but I don't see the benefits in hiding that information.\r\n\r\n---\r\n\r\n> If the cache is shared (eg. the terminal would load with the SDK path they'd set from another workspace), then that wouldn't be an issue - but I'm not sure if that's what you mean (since I'm not sure what the limitation is in that case).\r\n\r\n@DanTup but then extensions would pollute other workspace terminals and the opposite would be true. There will be many extensions that use this for many languages but I expect only 1 or 2 to be valid for any particular language. We don't want `NODE_OPTIONS` or `JAVA_HOME` set in terminals opened within Dart projects?",
      "user":"Tyriar"
    },
    {
      "comment":"> @DanTup but then extensions would pollute other workspace terminals\r\n\r\nIf you're caching the changes (eg. \"extension X appended Y to env var Z\") couldn't you just re-apply those only for activated extensions? (I'm assuming you could wait until the extensions-to-activate have been decided for a workspace but I don't know if that's true).\r\n\r\nIt's possible we'll get \"pollution\" from other extensions anyway (because right now extensions can be activated for other language types for all sorts of weird reasons - eg. https://github.com/microsoft/vscode/issues/88617 and https://github.com/microsoft/vscode/issues/73656). If there may be conflicts in behaviour, I think we're going to see issues anyway (though I don't think for basic PATH manipulation it'd cause problems).",
      "user":"DanTup"
    },
    {
      "comment":"> I'm assuming you could wait until the extensions-to-activate have been decided for a workspace but I don't know if that's true\r\n\r\n@DanTup depends how long that wait is I guess. I'm not familiar with this mechanism.",
      "user":"Tyriar"
    },
    {
      "comment":"I guess based on https://github.com/microsoft/vscode/issues/73656 it could be *up to* 7 seconds. I don't know what it generally works out as though.\r\n\r\nPersonally, I'd prefer to take the potential pollution from unactivated extensions over having users have to click buttons on the terminal the first time they opened a new project.\r\n\r\nWould it be an option to silently recycle the terminal if it had recently been created, never interacted with, and not running a process (at the time an extension registers variables)?",
      "user":"DanTup"
    },
    {
      "comment":"Feedback from API call:\r\n\r\n- Unknown: Caching is complicated and a new concept and we can largely defer what to do here exactly\r\n- Try changing append/prepend/replace into explicit methods on collection\r\n- Keep the generic name for potential future use by other components (debug, external terminal)\r\n- Since collections are extension-specific, there is the potential for clashes which would fail silently (and log) under the current proposal. Since checking this would largely be for troubleshooting we could log detailed into when running at the trace log level as I've already had requests asking for increased visibility into how the process' environment is set up as it's a little complicated and has multiple stages it goes though.\r\n- `get || create` would be a very common pattern, let's merge.\r\n\r\nNew API:\r\n\r\n```ts\r\n// This could be inlined into get/forEach if preferable\r\nexport interface EnvironmentVariableMutator {\r\n\t/**\r\n\t * The type of mutation that will occur to the variable.\r\n\t */\r\n\treadonly type: 'replace' | 'append' | 'prepend';\r\n\t\r\n\t/**\r\n\t * The value to use for the variable.\r\n\t */\r\n\treadonly value: string;\r\n}\r\n\r\nexport interface EnvironmentVariableCollection {\r\n\t// We should mention in docs that replace/append/prepend all overwrite each other's values\r\n\treplace(variable: string, value: string): void;\r\n\tappend(variable: string, value: string): void;\r\n\tprepend(variable: string, value: string): void;\r\n\tget(variable: string): EnvironmentVariableMutator | undefined;\r\n\tforEach(callback: (variable: string, diagnostics: EnvironmentVariableMutator, collection: EnvironmentVariableCollection) => any, thisArg?: any): void;\r\n\tdelete(variable: string): void;\r\n\tclear(): void;\r\n\tdispose(): void;\r\n}\r\n\r\nexport interface window {\r\n\t/**\r\n\t * Creates an environment variable collection for this workspace, enabling\r\n\t * changes to terminal environment variables. Creating an collection will\r\n\t * replace any existing collections for this workspace. This will fetch the\r\n\t * cached collection if one exists for this workspace.\r\n\t * @param persistent Whether the collection is cached for the workspace across\r\n\t * window reloads. When true the collection will be active immediately such\r\n\t * that terminal creation does not need to be blocked on extension activation\r\n\t * on successive reloads, additionally this API will return the cached\r\n\t * collection from the previous session. The collection will be invalidated\r\n\t * by uninstalling the extension or by creating a new one. Defaults to false.\r\n\t */\r\n\tgetEnvironmentVariableCollection(persistent?: boolean): EnvironmentVariableCollection;\r\n}\r\n```\r\n\r\nNew example usage:\r\n\r\n```ts\r\n// Fetch existing collection if available\r\nconst collection = window.getEnvironmentVariableCollection(true);\r\ncollection.prepend('PATH', '/foo/bar:');\r\ncollection.replace('JAVA_HOME', '/foo/baz');\r\n// ~1 second after a change occurs the terminal will diff the collection to see\r\n// if the stale indicator would need to be displayed. This delay is since each\r\n// individual `set` will send their own async messages to the renderer\r\n```",
      "user":"Tyriar"
    },
    {
      "comment":"> // We should mention in docs that replace/append/prepend all overwrite each other's values\r\n\r\nDo we need to implement it this way? I think storing them as a list of changes internally would not be very hard and would remove a stumbling block people may run into.",
      "user":"connor4312"
    },
    {
      "comment":"@connor4312 then it would mean we need to manage an array instead of single values of which some entries may be invalid (eg. append followed by replace). What is the maximum number of entries in this array? Also currently an extension could do this:\r\n\r\n```ts\r\nconst collection = window.createEnvironmentVariableCollection(true);\r\ncollection.prepend('PATH', '/foo/bar:');\r\ncollection.replace('JAVA_HOME', '/foo/baz');\r\n```\r\n\r\nIf it was an array you would have to clear it and/or get before setting:\r\n\r\n```ts\r\nconst collection = window.createEnvironmentVariableCollection(true);\r\ncollection.clear();\r\ncollection.prepend('PATH', '/foo/bar:');\r\ncollection.replace('JAVA_HOME', '/foo/baz');\r\n```",
      "user":"Tyriar"
    },
    {
      "comment":"If we merge operations, the maximum number of items would be 2 -- and append and a prepend, since replace would overwrite and then merge into either, and appends/prepends can always merge with themselves. It does get confusing with a cached response from createEnvironmentVariableCollection, however.",
      "user":"connor4312"
    },
    {
      "comment":"From standup: Should it be `get` instead of `create` since it may be fetching the cached one? (updated example)",
      "user":"Tyriar"
    },
    {
      "comment":"Created test plan and release notes, moving the API item to April",
      "user":"Tyriar"
    },
    {
      "comment":"I've merged in the initial proposed API so it should be available in Monday's Insiders build:\r\n\r\nhttps://github.com/microsoft/vscode/blob/02ccb95859803954b24ab3c3ae473b41a9ef4e78/src/vs/vscode.proposed.d.ts#L1136-L1234",
      "user":"Tyriar"
    },
    {
      "comment":"I've a fork of the direnv extension that uses this new feature, it works well for this purpose so far: tasks and other features that were previously unaffected now pick up the appropriate environment variables. I use this together with the nix integration in direnv.\r\n\r\nFor anyone interested: https://github.com/adamse/vscode-direnv",
      "user":"adamse"
    },
    {
      "comment":"Just had a UX call, I'll paste the notes I presented and main feedback I gathered. I'll follow up a comment of the plan for the iteration given this feedback soon.\r\n\r\n## Notes presented\r\n\r\n### Using the panel actions\r\n\r\nProbably not a good idea:\r\n\r\n- The panel acts on the level of all terminals, not a specific terminal\r\n- If an info/warning icon went here, it would change depending on which split was focused\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/78821078-c0c97800-798d-11ea-9916-cf6585f295ce.png)\r\n\r\n### Using the find widget as inspiration\r\n\r\nRight now there is only ever one find widget and it is always on the top right of the panel, even if the left split is focused. This is not great for find but won't work for environment indicators.\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/78821110-d2128480-798d-11ea-8c31-0f4f510f3ece.png)\r\n\r\nEnvironment changes active:\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/78821137-e0f93700-798d-11ea-8ec0-fb598d47ea9f.png)\r\n\r\nStale environment:\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/78821154-e6ef1800-798d-11ea-9b34-35ca5d18a2fc.png)\r\n\r\nWe could fade when not hovered:\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/78821181-eeaebc80-798d-11ea-8bb5-151ba9632b91.png)\r\n\r\nNo background/shadow and align with right-most icon when not hovered.\r\n\r\n- This could sit underneath the find widget\r\n- Since it's transparent you will be able to make out text underneath, you can always scroll if it's blocking (on normal buffer)\r\n- Minor issue: mouse events won't work in those 1 or 2 cells\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/78821206-f706f780-798d-11ea-8f8f-4f85fb49cb0a.png)\r\n\r\nTooltip could give info about why it's stale:\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/78821224-fcfcd880-798d-11ea-9cc0-2e9f135ad167.png)\r\n\r\nClicking the stale environment button could allow actioning, these could also have icons for faster recognition? â¬†, â™», âŒ\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/78821247-0423e680-798e-11ea-991c-c149d7956575.png)\r\n\r\nQuestion: Are these all useful or is this too complicated?\r\nQuestion: Maybe dismissal should not be possible for stale environment?\r\n\r\nStale environment button could call out which extensions have made changes - this would show for any terminal where environment changes have happened.\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/78821275-0e45e500-798e-11ea-8285-78b53be38364.png)\r\n\r\nClicking it could open a modal dialog explaining what's happening in more detail (editor or something else could work but modal seems appropriate?), for example:\r\n\r\n> The 'Python' extension\r\n> \t\r\n> - Added \"D:\\tools\\Python27\" to the beginning of the `PATH` environment variable\r\n> - Set the `PYTHONHOME` environment variable to \"D:\\dev\\myproject\"\r\n>\r\n> The 'Dart' extension\r\n>\t\r\n> - Added \"D:\\tools\\flutter\\sdk\" to the beginning of the `PATH` environment variable\r\n> - Added \"D:\\tools\\dart\\sdk\" to the beginning of the `PATH` environment variable\r\n> - Set the `ANDROID_HOME ` environment variable to \"D:\\android\\sdk\"\r\n\r\nQuestion: Is this level of detail desirable?\r\n\r\nShould we allow dismissing this one somehow? An x icon could show when you hover the info icon? The below would make the info icon move when hover though:\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/78821327-27e72c80-798e-11ea-8687-b5913069ef9b.png)\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/78821336-2b7ab380-798e-11ea-8347-9857c6424663.png)\r\n\r\n### Alternative idea for stale environment icon\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/78821349-31709480-798e-11ea-8d72-f7cd77e74ae1.png)\r\n![image](https://user-images.githubusercontent.com/2193314/78821356-33d2ee80-798e-11ea-96cb-817fba13e158.png)\r\n\r\n### Another idea: Always show info icon\r\n\r\nWhen there are no environment changes:\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/78821383-41887400-798e-11ea-8b28-aa038a34bfea.png)\r\n\r\n- Clicking could give general information about how the environment was constructed, and link to docs for diagnosing shell-side environment issues?\r\n- I get a many issues around why the environment is the way it is and this could go into even more detail than trace logging currently.\r\n- Maybe too in your face:\r\n  - Allow easy dismissal?\r\n  - Fade more than 50%?\r\n  - Only show the icon for the currently focused terminal?\r\n\r\nEnvironment changes active:\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/78821430-51a05380-798e-11ea-8de0-43820fc3d68f.png)\r\n\r\nStale environment:\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/78821447-582ecb00-798e-11ea-9994-ec30ee76352f.png)\r\n\r\n---\r\n\r\n## Feedback from team\r\n\r\n- Indicator button\r\n  - Don't make it a button so mouse events fall through.\r\n- Modal\r\n  - Use the rich hover from the editor, actions like Quick fixes on the bottom bar, this might be tricky as hover lives in editor?\r\n- Show info icon when changes are active, warning icon when stale\r\n- Do not show icon when no environment changes are visible, there could be a command that dumps general environment init information to a read only editor for better diagnostics.\r\n- We should consider accessibility",
      "user":"Tyriar"
    },
    {
      "comment":"## Current plan\r\n\r\nWhen no environment variable collections exist for the workspace: Nothing will show\r\n\r\nWhen there are active environment variable collections for the workspace (this will be partially transparency when not hovering):\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/78897342-dd65be80-7a26-11ea-983b-0448c410c84b.png)\r\n\r\nWhen the environment is stale (this will be partially transparency when not hovering):\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/78896739-cf636e00-7a25-11ea-9fbf-1563aaaa0312.png)\r\n\r\nI'll try and integrate rich hovers when hovering the indicator, that way the explanation can be done in markdown (links, code styles, lists) and the actions bar on the bottom will contain relevant actions.\r\n\r\nA new setting `terminal.integrated.environmentChangesIndicator: 'off' | 'on' | 'warnonly'` will determine when the indicator displays. Off would never show anything, on would show both the info and warn icons, warn only would only show warn.\r\n\r\nRegarding accessibility, I'm thinking of annotating the terminal when focused so instead of announcing \"Terminal 1\" it would announce \"Terminal 1 stale environment may require relaunch\". Additionally just like the command \"Show Hover\" there would be a command \"Terminal: Show Environment Changes\" that would show and focus the hover.",
      "user":"Tyriar"
    },
    {
      "comment":"I've read through this issue, but am still not sure if it solves the issue I created that was marked as a duplicate, see https://github.com/microsoft/vscode/issues/93561.\r\n\r\nAs I understand it, VS Code launches a login shell at startup in order to get e.g. development tools on `PATH` in this code (which I also assume loads other env vars than just `PATH`): https://github.com/microsoft/vscode/blob/5b7aa98201cf9442ce0252052268a8f3d9502fda/src/vs/code/node/shellEnv.ts#L33\r\n\r\nNow there exists many of the tools that alter environments per directory (i.e. per project) i.e. [direnv](https://direnv.net/), [Environment Modules](http://modules.sourceforge.net/), [autoenv](https://github.com/inishchith/autoenv), [zsh-autoenv](https://github.com/Tarrasch/zsh-autoenv), [asdf](https://github.com/asdf-vm/asdf), [ondir](https://github.com/alecthomas/ondir) and more. These tools are a growing trend, as it is very handy to setup specific versions of programs/dependencies per project/directory, as is often the case with open source. As a common example, let's say you set `PYTHONPATH` in a project to point out some specific Python packages in a project you are working on. The VS Code Python extension can then resolve this when editing a Python file and thus give me IntelliSense and proper imports when editing Python code.\r\n\r\nBut what these tools also let me do, as in the example of direnv, is to alter my `PYTHONPATH` in a file called `.envrc`. If I am in a terminal, direnv will then let me know I altered this file (and consequently my environment), ask me if I want to allow the change (a security feature) and if I type `direnv allow` it reloads the current shells enviroment with the new `PYTHONPATH`. This is cool, and magical and brings joy. No need to have to manually source a file.\r\n\r\nBut I have no idea how this would behave in VS Code and the env that was loaded on VS Code startup in the login shell. Although @adamse update to the direnv extension would re-load the VS Code environment (right?), it would still not work for all the other tools that exist out there.\r\n\r\nAs such I am wondering if this issue will solve it so that the actual environment loaded at VS Code startup will _also_ be reloaded in the current open VS Code process?\r\n\r\nMaybe I misunderstood all this, maybe what I am asking is not possible, or stupid or something, but it would be nice to be enlightened if this has already been thought of.\r\n\r\nAs an addition, how will this work with multi-root workspaces?",
      "user":"thernstig"
    },
    {
      "comment":"> As such I am wondering if this issue will solve it so that the actual environment loaded at VS Code startup will also be reloaded in the current open VS Code process?\r\n\r\n@thernstig this API will _not_ change VS Code's window process environment, only terminal and task processes created after it's set. Changing VS Code's window is off the table as too many things could go wrong, but regardless it's not `process.env` on the window you need to change, the Python extension which could be caching the `PYTHONPATH` for all your know.\r\n\r\nWith the changes, a direnv extension could fill in the environment based on the file for a particular workspace, it may conflict with other extensions trying to do something similar though.\r\n\r\n > As an addition, how will this work with multi-root workspaces?\r\n\r\nWhen a terminal is created it's associated with the last active workspace, the intent is for it to associate based on the folder. I can't remember exactly if this is covered yet though.",
      "user":"Tyriar"
    },
    {
      "comment":"@Tyriar Thank you for the information. As such, is the issue that was closed still valid, or is that something that is never going to happen/be possible?",
      "user":"thernstig"
    },
    {
      "comment":"I don't think it will happen.",
      "user":"Tyriar"
    },
    {
      "comment":"Ok, that makes me sad, since it require me to restart VS Code any time I change some environment setup for a project.",
      "user":"thernstig"
    },
    {
      "comment":"## Update\r\n\r\nI'm just in the process of adding the setting which should be in soon, the UI changes are merged in and will be in Monday's build. These screenshots were taken with the help of the new terminal-sample which calls this API https://github.com/microsoft/vscode-extension-samples/commit/81d47e06b17b11a6c20ec2ae5806594969736bf5\r\n\r\nWhen there are changes that need to be made:\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/79620263-320ed680-80c4-11ea-941b-33eb8f178b05.png)\r\n\r\nNew rich hover, the first one outside the editor. It includes an action to relaunch the terminal, this is a new command generally available which will kill the terminal process, clear the terminal and create a new process using the same launch configuration (but extension env changes will be refreshed):\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/79620292-48b52d80-80c4-11ea-9737-d3ca8b78f338.png)\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/79620325-66829280-80c4-11ea-8e6d-f5d18ca369fa.png)\r\n\r\nExample of splits and text under the indicator:\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/79620372-83b76100-80c4-11ea-9c11-12946d5baf22.png)\r\n\r\nInfo hover, also shows the hover gets anchored on the bottom if it doesn't have room available above:\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/79620414-a9dd0100-80c4-11ea-91e3-a7b3c91f08cf.png)\r\n\r\nHere it is in action:\r\n\r\n![91ff913d-be30-4278-812c-53f8784d5007](https://user-images.githubusercontent.com/2193314/79620476-e3157100-80c4-11ea-818a-f2f92a8b21fd.gif)\r\n",
      "user":"Tyriar"
    },
    {
      "comment":"Update:\r\n\r\nWe're going to move the API from `window` to `ExtensionContext` and make `persistent` a property (default: true) on `EnvironmentVariableCollection`:\r\n\r\n```ts\r\nexport interface ExtensionContext {\r\n\t/**\r\n\t * Creates or returns the extension's environment variable collection for this workspace,\r\n\t * enabling changes to be applied to terminal environment variables.\r\n\t */\r\n\treadonly environmentVariableCollection: EnvironmentVariableCollection;\r\n}\r\n\r\n\r\nexport interface EnvironmentVariableCollection {\r\n\t/**\r\n\t * Whether the collection should be cached for the workspace and applied to the terminal across\r\n\t * window reloads. When true the collection will be active immediately such when the window\r\n\t * reloads. Additionally, this API will return the cached version if it exists. The collection\r\n\t * will be invalidated when the extension is uninstalled or when the collection is disposed.\r\n\t * Defaults to true.\r\n\t */\r\n\tpersistent: boolean;\r\n}\r\n```\r\n\r\nI guess this would mean also getting rid of `EnvironmentVariableCollection.dispose` in favor of just using `EnvironmentVariableCollection.clear`.\r\n\r\nCurrent unknown is whether it should be named `workspaceEnvironmentVariableCollection`, if we want to eventually do a `globalEnvironmentVariableCollection`.",
      "user":"Tyriar"
    },
    {
      "comment":"Small thing: it would be nice to be able to accept the environment variable changes by clicking on the âš ï¸ icon. I've tried to do that a few times automatically before remembering I need to go to the link inside the tooltip.",
      "user":"connor4312"
    },
    {
      "comment":"@connor4312 accept as in relaunch the terminal? It's could lose work though",
      "user":"Tyriar"
    },
    {
      "comment":"Also right now click events go through to the terminal, so mouse events still work there even if the info/warning icon is visible.",
      "user":"Tyriar"
    },
    {
      "comment":"> accept as in relaunch the terminal? It's could lose work though\r\n\r\nYea. It is dangerous but it's not an area I click very often, so I would feel safe that I wouldn't accidentally click it. The âš ï¸ state is also not one that users should want to stay in for very long.\r\n\r\n---\r\n\r\nWhen implementing auto-attach using this API I ran into some awkwardness from the fact that the debug-auto-launch extension couldn't read the environment variables that js-debug had exposed. Some more details here, it would be nice (for me ðŸ˜› ) if we could expose some kind of reflection API: https://github.com/microsoft/vscode/pull/95807",
      "user":"connor4312"
    },
    {
      "comment":"Just had a discussion about this, it will probably eventually move into the the terminal tab https://github.com/microsoft/vscode/issues/10546 near the x",
      "user":"Tyriar"
    },
    {
      "comment":"@connor4312 can js-debug depend on debug-auto-launch and the environment contribution is done by debug-auto-launch?",
      "user":"Tyriar"
    },
    {
      "comment":"The difficulty there is that the environment variables must be unset when the extension is uninstalled or updated, otherwise NODE_OPTIONS will --require a file that doesn't exist and fail any `node` commands.",
      "user":"connor4312"
    },
    {
      "comment":"> Yea. It is dangerous but it's not an area I click very often, so I would feel safe that I wouldn't accidentally click it. The âš ï¸ state is also not one that users should want to stay in for very long.\r\n\r\nSince the warning should not show up often (maybe when you install new extensions), I think the way to go is to make it a little more difficult to trash your terminal. There may also be additional ways to action it in the future (eg. Don't show again).",
      "user":"Tyriar"
    },
    {
      "comment":"To accomadate larger env var names and values the plan it to change the hover format to:\r\n\r\n> Extensions have made changes to this terminal's environment:\r\n> \r\n> ```\r\n> VSCODE_GIT_IPC_HANDLE=/tmp/vscode-git-ipc-blah...\r\n> FOO=${env:FOO}BAR\r\n> BAR=FOO${env:BAR}\r\n> ```\r\n\r\nhttps://github.com/microsoft/vscode/issues/96250",
      "user":"Tyriar"
    },
    {
      "comment":"To verifier: Do some basic verification of the `ExtensionHost.environmentVariableCollection` API, no test plan since no changes have really happened since the proposed API was tested.",
      "user":"Tyriar"
    }
  ],
  "repository":"vscode",
  "user":"DanTup"
}